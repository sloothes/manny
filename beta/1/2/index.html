<!DOCTYPE html>
<html lang="en">
	<head>

		<title>mannyTheSkeleton: Swordplay (beta 1.2)</title>

		<meta charset="utf-8">
		<meta name="generator" content="HTML-Editor">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">

		<link rel="stylesheet" href="/css/joystick.css">
		<link rel="stylesheet" href="/css/bootstrap.min.css">
		<link rel="stylesheet" href="/css/bootbox-dialoges.css">

		<script src="/js/watch.js"></script>
		<script src="/js/jquery.min.js"></script> 
		<script src="/js/system.min.js"></script>
		<script src="/js/signals.min.js"></script>
		<script src="/js/inflate.min.js"></script>
		<script src="/js/zangodb.min.js"></script>
		<script src="/js/bootstrap.min.js"></script>
		<script src="/js/hold-event.min.js"></script>

		<style>

			body {
				font-family: sans-serif;
				font-size: 13px;
				background-color: #000;
				margin: 0px;
				overflow: hidden;
			}

			#loading-bar {
				width:100%;
				height:100%;
				top:0; left:0;
				position:fixed;
				display:flex;
				align-items:center;
				justify-content:center;
			}

			.middle > * {
				top:0; 
				left:0;
				right:0;
				bottom:0;
				margin:auto;"
				position:absolute;
			}

			#joystick1 {
				right: calc(40px + 370px);
			}
			
			#jumpButton {
				right: calc(105px + 370px);
			}

			.btn-action {
				padding:0;
				width:55px;
				height:55px;
				border:1px solid;
				border-radius:4px;
				margin-right:4px;
				margin-bottom:4px;
				display:inline-block;
			}
			
			.btn-action + .btn-action {
				margin-right:4px;
			}

			.btn-matcap {
				padding:0;
				float:left;
				width:55px;
				height:55px;
				border:1px solid;
				border-radius:4px;
				margin-right:4px;
				margin-bottom:4px;
				display:inline-block;
			}
			
			.btn-matcap + .btn-matcap {
				margin-right:4px;
			}

		</style>
	</head>

	<body ontouchstart="">

		<script src="/manny/js/three.js"></script>
		<script src="/manny/js/TabUI.js"></script>
		<script src="/manny/js/MeshWalk.js"></script>
		<script src="/manny/js/UVsDebug.js"></script>
		<script src="/manny/js/FBXLoader.js"></script>
		<script src="/manny/js/VirtualInput.js"></script>
		<script src="/manny/js/EditorControls.js"></script>
		<script src="/manny/js/camera-controls.js"></script>
		<script src="/manny/js/SubdivisionModifier.js"></script>
		<script src="/manny/js/three-pathfinding.umd.js"></script>
		<script src="/threejs/r96/examples/js/loaders/GLTFLoader.js"></script>
		<script src="/threejs/r96/examples/js/exporters/GLTFExporter.js"></script>
		<script src="/threejs/r96/examples/js/exporters/STLExporter.js"></script>
		<script src="/threejs/r96/examples/js/exporters/OBJExporter.js"></script>
		<script src="/threejs/r96/examples/js/exporters/ColladaExporter.js"></script>

		<script>

			debugMode = true; // important!
			MW.install( THREE ); // important!

		//	CameraControls.install( {THREE:THREE} ); // demo!
		//	THREE.Pathfinding = threePathfinding.Pathfinding;
		//	THREE.PathfindingHelper = threePathfinding.PathfindingHelper;
		//	IMPORTANT NOTE: at "/manny/js/three.js" (r96),
		//	we comment line 43269: "// if ( object.visible === false ) return;"

			Number.prototype.format = function (){
				return this.toString().replace(/(\d)(?=(\d{3})+(?!\d))/g, "$1,");
			};

			function round(number, precision) {
				var shift = function (number, precision, reverseShift) {
					if (reverseShift) {
						precision = -precision;
					}  
					numArray = ("" + number).split("e");
					return +(numArray[0] + "e" + (numArray[1] ? (+numArray[1] + precision) : precision));
				};
				return shift(Math.round(shift(number, precision, false)), precision, true);
			}

		</script>

		<script>

			(function(){

			//	const w = 370; // important!

			//	Scene.
				scene = new THREE.Scene();

			//	Camera.
				(function(){

					var aspect = (window.innerWidth - 370) / window.innerHeight;
					camera = new THREE.PerspectiveCamera( 50, aspect, 1, 100000 );
					camera.position.set(0, 5, 25);

				})();

			//  Camera Light.
				(function(){

					cameraLight = new THREE.DirectionalLight( 0xdfebff, 0.75 );
					cameraLight.position.set( 0, 500, 300 );
					cameraLight.castShadow = true;
					cameraLight.shadow.mapSize.width  = Math.pow(2, 10); // 2048;
					cameraLight.shadow.mapSize.height = Math.pow(2, 10); // 2048;

					var d = 30;
					cameraLight.shadow.camera.left = - d;
					cameraLight.shadow.camera.right = d;
					cameraLight.shadow.camera.top = d;
					cameraLight.shadow.camera.bottom = - d;
					cameraLight.shadow.camera.far = 10000;

					shadowHelper = new THREE.CameraHelper(cameraLight.shadow.camera);
					shadowHelper.visible = false;

					scene.add( cameraLight, shadowHelper  );

					(function update(){
						requestAnimationFrame( update );
						cameraLight.position.copy( camera.position );
					})();

				})();

			//  Renderer.
				(function(){

					renderer = new THREE.WebGLRenderer({
						antialias: true,
						preserveDrawingBuffer: true,
					});

					renderer.gammaInput = true;
					renderer.gammaOutput = true;
					renderer.shadowMap.enabled = true;
					renderer.setClearColor( 0x000000 );
					renderer.setPixelRatio( window.devicePixelRatio );
					renderer.setSize( (window.innerWidth - 370), window.innerHeight );
					document.body.appendChild( renderer.domElement );

					window.addEventListener("resize", function onWindowResize() {
						renderer.setSize( (window.innerWidth - 370), window.innerHeight );
					});

					window.addEventListener("resize", function onWindowResize() {
						camera.aspect = renderer.domElement.clientWidth / renderer.domElement.clientHeight;
						camera.updateProjectionMatrix();
					});

					mouse = new THREE.Vector2();

					renderer.domElement.addEventListener("mousemove", function(e) {
						mouse.x = ( e.clientX / this.clientWidth ) * 2 - 1;
						mouse.y = - ( e.clientY / this.clientHeight ) * 2 + 1;
					});

					(function render(){
						requestAnimationFrame( render );
						renderer.render( scene, camera );
					})();

				})();

			//	Editor Controls.
				setTimeout(function(){
					controls = new THREE.EditorControls(camera, renderer.domElement);
					controls.center.set(0, 10, 0);
					camera.lookAt(controls.center); // important!
				});

			})();

		//	World - Octree.

			(function(){

				world = new MW.World();

				var x = 1500, y = 1500, z = 1500;
				var min = new THREE.Vector3( -x, -y, -z );
				var max = new THREE.Vector3(  x,  y,  z );
				var partition = 1; // nodes: Math.pow( 8, partition )

				octree = new MW.Octree( min, max, partition );
				world.add( octree );

				var clock = new THREE.Clock();

				(function update(){
					requestAnimationFrame( update );
					var delta = clock.getDelta();
					var elapsed = clock.getElapsedTime();
					world.step( Math.min( delta, 0.02 ) );
					scene.updateMatrixWorld(); // important!
				})();

			})();

			(function(){

			//	ground.
				ground = new THREE.Mesh(
					new THREE.PlaneGeometry( 3000, 3000, 1, 1 ).rotateX(-Math.PI/2),
					new THREE.MeshLambertMaterial({ 
						opacity:1, 
						color:0x829ec4,
					})
				);

			//	We need only the geometry of the ground
			//	so there is not need to add to the scene.
			//	ground.rotation.x = -Math.PI / 2;
				octree.importThreeMesh( ground ); // important!
			//	scene.add( ground ); // optional!

			//	Ground Helper.
				groundHelper = new THREE.GridHelper( 3000, 300, 0x444444, 0x444444 );
				scene.add( groundHelper );

			//	Ground Raycaster.
				setTimeout(function(){
					var raycaster = new THREE.Raycaster();
					var intersecthelper = new THREE.Mesh(
						new THREE.CircleBufferGeometry( 2, 32 ).rotateX(-Math.PI/2),
						new THREE.MeshBasicMaterial({color:0xffff00, wireframe:false})
					);
					renderer.domElement.addEventListener("mousemove", function(e) {
						camera.updateMatrixWorld(); // important!
						raycaster.setFromCamera( mouse, camera );
						var intersects = raycaster.intersectObject( ground );
						if ( !intersects.length ) return;
						intersecthelper.position.copy( intersects[0].point );
					});
					intersecthelper.visible = debugMode;
					scene.add( intersecthelper );
				});

			})();

		</script>

		<script>

		//	TabUI

			(function(){

				var sidePanel = createSidePanel();
				var gameTab = TabUI.add( "Game", "game-tab" );
				var debugTab = TabUI.add( "Debug", "debug-tab" );
				var playersTab = TabUI.add( "Players", "player-tab" );
				var materialTab = TabUI.add( "Materials", "material-tab" );
				var animationsTab = TabUI.add( "Animations", "animation-tab" );

			//	var loginTab = TabUI.add( "Login", "login-tab" );
			//	var weponTab = TabUI.add( "Wepon", "wepon-tab" );
			//	var levelTab = TabUI.add( "Levels", "level-tab" );
			//	var cameraTab = TabUI.add( "Camera", "camera-tab" );
			//	var actionTab = TabUI.add( "Actions", "action-tab" );
			//	var controlTab = TabUI.add( "Controls", "control-tab" );

				document.body.appendChild( sidePanel );
				TabUI.append( "Game", "Animations", "Materials", "Players" );
				TabUI.Game.role.classList.add("active");
				TabUI.Game.tab.classList.add("in","active");

			})();

		</script>

		<script>

		//	Material Tab.

			(function(){

				var tab = TabUI.Materials.tab;

				var row = document.createElement("h3");
				row.textContent = "Material";

				var Signal = signals.Signal;
				materialSelected = new Signal();

				var select = document.createElement("select");
				select.id = "material-droplist";
				select.style.cssText = "width:180px;color:#000;" // float:left;
					+ "border:1px solid;border-radius:4px;padding:2px 4px 4px 4px;"
					+ "font-size:20px;margin-left:10px;";

				row.appendChild( select );
				tab.appendChild( row );

			})();

			(function(){

				var material;
				var textures = {};
				var tab = TabUI.Materials.tab;
				var Signal = signals.Signal;
				var textureClicked = new Signal();

				textures.dispose = function(){
					for (var uuid in this ) {
						var texture = this[ uuid ];
						texture.dispose && texture.dispose();
					}
				}

				textureClicked.add( function( uuid ){
					material.roughness = 0;
					material.metalness = 1;
					material.envMap = textures[ uuid ];
					material.envMap.needsUpdate = true;
					material.needsUpdate = true;
				});

				var matcaps = (
				//	"MZV8PzS,L509oY2,Bw7q38p,2FA0yx1,vVDGl7g,3nmnKd4,E36SPOB,MXqauTz,YHsPLdq,soRJv4a," // (large:2K)
					"bixnsMm,MS1GDja,pUytALG,4KwC8wH,Wiqsp9s,gXRFY3U,2tkhy7C,D64zaTR,Id8k2u4,Fx9154f,"
					+ "dqKYFPo,l0Lf1LN,7bH7Ajw,IeAwKEi,VysdwUU,dWAhf12,9ufYr2S,iAWd8i1,mkGDAn5,gf3PsvD,"
					+ "BeHwxKA,GYBQ8Xr,9gxylAS,0p2RT39,aHeUCko,epbmrGs,NKMFDGB,pvXMCj9,QbZ8H2v,aCAVXQb,"
					+ "qU0AEUM,yvwt1wj,D5UeFcC,6GZMeko,rSlm3oM,Xqg7n0A,PzHZLHy,MEzwCJq,wgf7Vl0,GcLQiey,"
					+ "3xH34nj,vhdhgMe,jRTIv3l,xELCxlQ,wtJaViy,Qb0qKtc,7kq8wQ3,F6kcile,0LRxFql,rxUXS8C,"
					+ "qXg0NKn,LSB7hqR,EolEkFt,gOtyiMy,YTE0R32,thsIYPF,ee6stBn,gyYhQao,QOEE3jO,0V4rQPV,"
					+ "l9Tugo0,R86xHzg,IDlk0H9,tUparH7,GISkhjO,JQzRceW,Jl6XqD0,4tyRlwP,aFIJ3Iu,BCqRnS4,"
					+ "1OcGlAa,PqIxyYE,S7J95Cf,QPUvzXD,Stdy1eT,k0nOt5N,rWuDYYe,SGRUmyD,1Ia4Qbk,FFYLtQa,"
					+ "szmc38X,NJSPJlS,8HsVNJA,n3wbE5E,88autaS,7jwTUiI,H1F3Yrv,kgV7aSY,PDFIrWw,Uun8Lpr,"
					+ "Oz16d2L,02gRNwL,bV94g46,eUEtBHC,e1N7JYN,bWpofvm,uzlo3mR,YaXveL2,mw2f1lF,HkWGQb1,"
					+ "N9xoehs,53rWmmo,sBPySdS,1YZKblR,ywKHb7r,3UcbBN7,pWPtSJS,n1a2nB8,lecZa2Q,e3bxY9I,"
					+ "WxVSuFW," // normal matcap.
				).split(",")

				matcaps.pop(); // removes last empty item. (important!)

				var container = document.createElement("div");
				container.id = "matcap-buttons";
				container.style.width = "300px";

				while ( matcaps.length ) {
					(function( id ){

						var button = document.createElement("div");
						button.id = id;
						button.classList.add("btn", "btn-white-outline", "btn-matcap");
						button.style.cssText = "background-size:contain;background-image:url(https://i.imgur.com/"+id+"s.png);";
					//
						var url = "https://i.imgur.com/"+id+".png";   // TODO: cache matcaps.
						var loader = new THREE.ImageLoader();
						loader.setCrossOrigin("anonymous");						// important!
						loader.load( url, function( image ){
							var mapping = THREE.SphericalReflectionMapping;		// important!
							var texture = new THREE.Texture( image, mapping );	// important!
							texture.sourceFile = url;							// important!
							textures[ texture.uuid ] = texture;
							button.setAttribute("uuid", texture.uuid);
							container.appendChild( button );
						});
					//
						button.addEventListener( "click", function(){
							var select = document.getElementById("material-droplist");
							var selected = scene.getObjectByProperty("uuid", select.value);
							if ( !selected ) return;
							var material = selected.material;
							if ( !material ) return;
							var uuid = button.getAttribute("uuid");
							material.roughness = 0;
							material.metalness = 1;
							material.envMap = textures[ uuid ];
							material.envMap.needsUpdate = true;
							material.needsUpdate = true;
							textures.dispose();
						//	textureClicked.dispatch( uuid );
						});

					})( matcaps.shift() );

				}

				tab.appendChild( container );

			})();

		</script>

		<script>

		//	Games tab.

			(function(){

			//	Players droplist.

				var players = {}; // local.
				currentPlayer = "player1"; // global.

				var tab = TabUI.Game.tab;
				var row = document.createElement("h3");
				row.style.cssText = "padding-right:16px;";
				row.textContent = "Player:";

				var select = document.createElement("select");
				select.id = "players-droplist";
				select.style.cssText = "width:180px;color:#000;float:right;"
				+ "border:1px solid;border-radius:4px;padding:2px 4px 4px 4px;"
				+ "font-size:20px;margin-left:10px;";
				
				select.addEventListener( "change", function(){
					currentPlayer = this.value;
				});

				select.addPlayer = function( key, object, selected ){
					if ( !( key && object ) ) return;
					players[ key ] = object;
					var option = document.createElement("option");
					option.text = option.value = key;
					if ( selected ) {
						currentPlayer = option.value;
						option.setAttribute("selected", "");
					}
					select.appendChild( option );
				};

				select.getPlayer = function( key ){
					if ( key ) return players[ key ];
					return players[ this.value ];
				};

				select.getAnimationController = function( key ){
					if ( key ) return players[ key ].animationController;
					return players[ this.value ].animationController;
				};

				select.getSkeletonHelper = function( key ){
					if ( key ) return players[ key ].skeletonHelper;
					return players[ this.value ].skeletonHelper;
				};

				select.addMotion = function( name, clip ){
					for ( var key in players ) {
						if ( !( key && players[key] ) ) return;
						var animationController = this.getAnimationController( key );
					//	if ( animationController.motion[ name ] ) return; // or let to replace motion?
						var mixer = animationController.mixer;
						var object = animationController.object;
						animationController.motion[ name ] = mixer.clipAction( clip, object );
					}
				};

				row.appendChild( select );
				tab.appendChild( row );

			})();

		</script>

		<script>

		//	Animation tab.

			(function(){

			//	Animation droplist.

				currentAnimation = "idling";
				var animations = []; // local.

				var tab = TabUI.Animations.tab;
				var row = document.createElement("h3");
				row.style.cssText = "padding-right:0px;";
				row.textContent = "Animation:";

				var select = document.createElement("select");
			//	select.animations = {}; // important!
				select.id = "animation-droplist";
				select.style.cssText = "width:180px;color:#000;float:right;"
					+ "border:1px solid;border-radius:4px;padding:2px 4px 4px 4px;"
					+ "font-size:20px;margin-left:10px;";

				(function(){
					var option = document.createElement("option");
					option.text = option.value = currentAnimation;
					select.appendChild( option );
				})();

				select.addEventListener( "change", function(){
					currentAnimation = this.value;
				});

				select.addEventListener( "change", function(){
					var select = document.getElementById("players-droplist");
					var animationController = select.getAnimationController( currentPlayer );
					if ( !( select && animationController ) ) return; 
					if ( !animationController.motion.idling ) return;
					animationController.play( "idling" );
				});

				select.addAnimation = function( name, clip ){
					animations.push( clip );
					var option = document.createElement("option");
					option.text = option.value = name;
					this.appendChild( option );
				};

				select.getAnimationByName = function( name ){
					return animations.find(function( clip ){
						return clip.name == name;
					});
				};
				
				select.getAnimationByUUID = function( uuid ){
					return animations.find(function( clip ){
						return clip.uuid == uuid;
					});
				};

				select.getAnimations = function(){
					return animations;
				};

				row.appendChild( select );
				tab.appendChild( row );

			})();


			(function(){

			//	Animation Test Button.

				var tab = TabUI.Animations.tab;
				var row = document.createElement("div");
				row.style.cssText = "margin:20px 12px 10px;height:35px;text-align:center;";

				var button1 = IdleButton();
				var button2 = TestButton();
				row.appendChild( button1 );
				row.appendChild( button2 );

				tab.appendChild( row );

				function IdleButton(){

					var button = document.createElement("div");
					button.id = "idle-animation";
					button.textContent = "Pause";
					button.title = "Pause animation action";
					button.style.cssText = "width:33%;float:left;height:40px;font-size:large;";
					button.classList.add( "form-control", "btn", "btn-primary", "btn-white-outline", "gradient-btn" );
					button.addEventListener( "click", function(){
						var select = document.getElementById("players-droplist");
						var animationController = select.getAnimationController( currentPlayer );
						if ( animationController.currentMotionName == "idling" ) return;
						animationController.play( "idling" ); 
					});

					return button;
				}

				function TestButton() {

					var button = document.createElement("div");
					button.id = "play-animation";
					button.textContent = "Test animation";
					button.title = "Test animation action";

					button.style.cssText = "width:65%;float:right;height:40px;font-size:large;";
					button.classList.add( "form-control", "btn", "btn-primary", "btn-white-outline", "gradient-btn" );
					button.addEventListener( "click", function(){
						var select = document.getElementById("players-droplist");
						var animationController = select.getAnimationController( currentPlayer );
					//	if ( animationController.currentMotionName == currentAnimation ) return;
						animationController.motion[currentAnimation].reset();
						animationController.play( currentAnimation );
					});

					return button;
				}

			})();


			(function(){

			//	Action Add Button.

				var idleInterval; // important!

				var tab = TabUI.Animations.tab;
				var row = document.createElement("div");
				row.style.cssText = "margin:20px 12px 10px;height:35px;text-align:center;";

				var addButton = AddActionButton();
				var rmvButton = RemoveActionButton();

				row.appendChild( rmvButton );
				row.appendChild( addButton );

				tab.appendChild( row );

				function AddActionButton(){

					var button = document.createElement("div");
					button.id = "add-action";
					button.textContent = "Add Action";
					button.title = "Add action button";
					button.style.cssText = "width:49%;height:40px;float:right;font-size:large;";
					button.classList.add( "form-control", "btn", "btn-primary", "btn-white-outline", "gradient-btn" );
					button.addEventListener( "click", function(){

						if ( currentAnimation == "idling" ) return;
						if ( document.getElementById( currentAnimation ) ) return;
						
						var animationDroplist = document.getElementById("animation-droplist");
						if ( !animationDroplist.getAnimationByName( currentAnimation ) ) return;

						var clip = animationDroplist.getAnimationByName( currentAnimation );
						document.getElementById("players-droplist").addMotion( currentAnimation, clip );

						var actionButton = document.createElement("div");
						actionButton.id = currentAnimation;
						actionButton.title = currentAnimation;
						actionButton.classList.add("btn", "btn-white-outline", "btn-action");
						actionButton.style.cssText = "background-size:contain;"
						+ "background-image:url('/manny/animations/thumbs/"+currentAnimation+".png');";

						actionButton.addEventListener( "click", function(){  /* TODO */  });

						document.getElementById("action-buttons").appendChild( actionButton );

					});

					return button;
				}

				function RemoveActionButton(){

					var button = document.createElement("div");
					button.id = "remove-action";
					button.textContent = "Remove";
					button.title = "Remove action button";
					button.style.cssText = "width:49%;height:40px;float:left;font-size:large;";
					button.classList.add( "form-control", "btn", "btn-primary", "btn-white-outline", "gradient-btn" );
					button.addEventListener( "click", function(){
						if ( !document.getElementById(currentAnimation) ) return;
						document.getElementById(currentAnimation).remove();
					});

					return button;
				}

			})();

			setTimeout(function(){

			//	Animation Import Button.

				var tab = TabUI.Animations.tab;
				var row = document.createElement("div");
				row.style.cssText = "margin:20px 12px 10px;height:35px;text-align:center;";

				var button = document.createElement("div");
				button.id = "import-animation";
				button.textContent = "Import animations";
				button.style.cssText = "width:100%;height:40px;font-size:large;";
				button.classList.add( "form-control", "btn", "btn-primary", "btn-white-outline", "gradient-btn" );

				var input = document.createElement("input");
				input.type = "file";
				input.style.display = "none";
				input.setAttribute("multiple", "");

				var k = 0; // important!

				input.addEventListener( "change", function(){

					var select = document.getElementById("animation-droplist");
					if ( !select ) { input.value = ""; return; }

					for ( var i = 0; i < input.files.length; i++ ) {
						(function( file ){

							var filename = file.name.replace(".fbx", "");
							var extension = file.name.split( "." ).pop().toLowerCase();

							var reader = new FileReader();

							reader.addEventListener( "progress", function ( e ) {
								var size = "(" + Math.floor( e.total / 1000 ).format() + " KB)";
								var progress = Math.floor( ( e.loaded / e.total ) * 100 ) + "%";
							//	debugMode && console.log( "Loading", filename, size, progress );
							});

							reader.addEventListener( "load", function ( e ) {

								var data = reader.result;
								var loader = new THREE.FBXLoader();
								var group = loader.parse( data );
							//	debugMode && console.log( group.animations );

								if ( !( group.animations && group.animations.length ) ) return;

							//	Add animations.
								group.animations.forEach( function( clip ){

									clip.name = filename;

									document.getElementById("animation-droplist").addAnimation( filename, clip );

								});

							}, false );

							reader.readAsArrayBuffer( file );

						})( input.files[i] );
					}

				});

				button.addEventListener( "click", function(){

					input.value = "";
					input.click();

				});

				button.appendChild( input );
				row.appendChild( button );
				tab.appendChild( row );

			});

		</script>

		<script>

		//	Game tab.

			var P1, P2;
			isFighting = false;

			(function(){

			//	Action buttons container.

				var tab = TabUI.Game.tab;
				var container = document.createElement("div");
				container.id = "action-buttons";
				container.style.cssText = "width:101%;max-height:300px;text-align:center;"
					+ "margin-top:20px;margin-bottom:20px;overflow-y:auto;";

				container.addEventListener( "click", actionButtonsClickHandler );

				tab.appendChild( container );

			})();

			function actionButtonsClickHandler(e){
			//	debugMode && console.log( e.target );

				if ( this.id == e.target.id ) return;

				var action = e.target.id;
				var reaction = "Hit Reaction From The Front With Bow (2)";
				if ( !action ) return;  debugMode && console.log( action );

				if ( !isFighting ) showcaseAction( action );
				else if ( isFighting ) fightingAction( action, reaction );

			}

		//	Load animations.

			(function(){

				var playersDroplist = document.getElementById("players-droplist");
				var animationDroplist = document.getElementById("animation-droplist");

				var swordfiles = [
					"great sword slash.fbx",
					"great sword slash (2).fbx",
					"great sword slash (3).fbx",
					"great sword slash (4).fbx",
					"great sword slash (5).fbx",
				];

				swordfiles.forEach( function( filename ){
					var loader = new THREE.FBXLoader();
					loader.load( escape("/manny/animations/sword/"+filename), function( group ){
						if ( !( group.animations && group.animations.length ) ) return;

						var clip = group.animations[0];
						clip.name = filename.replace(".fbx", "");

						animationDroplist.addAnimation( clip.name, clip );

						var reaction = "Hit Reaction From The Front With Bow";

						switch ( clip.name ) {
								
							case "great sword slash":
								reaction = "Hit In The Shoulder And Falls To The Ground";
							break;

							case "great sword slash (2)":
							case "great sword slash (3)":
							case "great sword slash (4)":
							case "great sword slash (5)":
								reaction = "Hit Reaction From The Front With Bow (2)";
							break;

						}

						AddActionButton( clip, reaction );

					});
				});

				var kickfiles = [
					"A Roundhouse Kick To The Side Of An Opponent.fbx",
					"Aerial 360 Degree Front Side Rotation Kick With Rear Foot.fbx",
				];

				kickfiles.forEach(function( filename ){
					var loader = new THREE.FBXLoader();
					loader.load( escape("/manny/animations/kick/"+filename), function( group ){
						if ( !( group.animations && group.animations.length ) ) return;

						var clip = group.animations[0];
						clip.name = filename.replace(".fbx", "");

						animationDroplist.addAnimation( clip.name, clip );

						var reaction = "Hit In The Shoulder And Falls To The Ground";

						switch ( clip.name ) {
								
							case "A Roundhouse Kick To The Side Of An Opponent":
							case "Aerial 360 Degree Front Side Rotation Kick With Rear Foot":
								reaction = "Hit In The Shoulder And Falls To The Ground";
							break;

						}

						AddActionButton( clip, reaction );

					});
				});

				var reactionfiles = [
					"Hit Reaction From The Front With Bow.fbx",
					"Hit Reaction From The Front With Bow (1).fbx",
					"Hit Reaction From The Front With Bow (2).fbx",
					"Hit In The Shoulder And Falls To The Ground.fbx",
				];

				reactionfiles.forEach(function( filename ){
					var loader = new THREE.FBXLoader();
					loader.load( escape("/manny/animations/reaction/"+filename), function( group ){
						if ( !( group.animations && group.animations.length ) ) return;

						var clip = group.animations[0];
						clip.name = filename.replace(".fbx", "");

						animationDroplist.addAnimation( clip.name, clip );
					});
				});
				
				var movementfiles = [
					"great sword walk forward.fbx",
					"great sword walk backward.fbx",
				];
				
				movementfiles.forEach(function( filename ){
					var loader = new THREE.FBXLoader();
					loader.load( escape("/manny/animations/movements/"+filename), function( group ){
						if ( !( group.animations && group.animations.length ) ) return;

						var clip = group.animations[0];
						clip.name = filename.replace(".fbx", "");

						animationDroplist.addAnimation( clip.name, clip );
					});
				});

				function AddActionButton( clip, reaction ){

					var interval;
					if ( !reaction ) reaction = "Hit Reaction From The Front With Bow (2)";
					
					var button = document.createElement("div");
					button.id = button.title = clip.name;
					button.classList.add("btn", "btn-white-outline", "btn-action");
					button.style.cssText = "background-size:contain;background-color:#fff;"
					+ "background-image:url('/manny/animations/thumbs/"+clip.name+".png');";

					document.getElementById("action-buttons").appendChild( button );

				}

			})();

		</script>

		<script>

		//	player controller.

			var playerRadius = 10;
			var sphere = new THREE.Mesh(
				new THREE.SphereGeometry( playerRadius, 8, 6 ),
				new THREE.MeshBasicMaterial( { color: 0xff0000,  wireframe: true} )
			);

			scene.add( sphere );
			sphere.position.set( 10, 10, 0 );

			playerController = new MW.CharacterController( sphere, playerRadius );

		//	keyInput controls.

			keyInputControls = new MW.KeyInputControl();
			debugMode && console.log ( keyInputControls );

			keyInputControls.addEventListener( "movekeyon", function () { 
				playerController.isRunning = true; // debugMode && console.log ( "movekeyon" );
			});

			keyInputControls.addEventListener( "movekeyoff", function () { 
				playerController.isRunning = false; // debugMode && console.log ( "movekeyoff" );
			});

			keyInputControls.addEventListener( "movekeychange", function () { 
				playerController.direction = keyInputControls.frontAngle;
			});

			//	keyInputControls.addEventListener( "jumpkeypress", function () { 
			//		playerController.jump(); // debugMode && console.log ( "jumpkeypress" );
			//	});

			world.add( playerController ); // important!

		</script>

		<script>

			function keyupActionEventHandler(e){
			//	debugMode && console.log( e );

				var action; // "great sword slash";
				var reaction = "Hit Reaction From The Front With Bow (2)";

				switch ( e.keyCode ){

					case 49: //	e.key: "1"
						action = "great sword slash";
					break;

					case 50: //	e.key: "2"
						action = "great sword slash (2)";
					break;

					case 51: //	e.key: "3"
						action = "great sword slash (3)";
					break;

					case 52: //	e.key: "4"
						action = "great sword slash (4)";
					break;

					case 53: //	e.key: "5"
						action = "great sword slash (5)";
					break;

					case 69: // e.key "e"
						action = "A Roundhouse Kick To The Side Of An Opponent";
						reaction = "Hit In The Shoulder And Falls To The Ground";
					break;

					case 81: // e.key "q"
						action = "Aerial 360 Degree Front Side Rotation Kick With Rear Foot";
						reaction = "Hit In The Shoulder And Falls To The Ground";
					break;

				}

				if ( !action ) return;  // debugMode && console.log( action );

				if ( !isFighting ) showcaseAction( action );
				else if ( isFighting ) fightingAction( action, reaction );

			}

			function fightingAction( action, reaction ){
				
				document.removeEventListener( "keyup", keyupActionEventHandler, false );
				document.getElementById("action-buttons").removeEventListener( "click", actionButtonsClickHandler );

				var reactionInterval;
				var requestAnimationFrameID; // important!

				var raycaster = new THREE.Raycaster(); raycaster.far = 9;
				var arrow = new THREE.ArrowHelper( raycaster.ray.direction, raycaster.ray.origin, raycaster.far );

				//	var p1, p2;
				//	if ( currentPlayer == "player1" ) { p1 = P1; p2 = P2; }
				//	else if ( currentPlayer == "player2" ) { p1 = P2; p2 = P1; }

				switch ( currentPlayer ) {

					case "player1": {
						var p1 = P1; 
						var p2 = P2;
					} break;

					case "player2": {
						var p1 = P2; 
						var p2 = P1;
					} break;

					default: {
						var p1 = P1; 
						var p2 = P2;
					} break;

				}

				p1.animationController.mixer.addEventListener( "finished", function raycasterEventHandler(e){
					p1.animationController.mixer.removeEventListener( "finished", raycasterEventHandler );

					cancelAnimationFrame( requestAnimationFrameID ); // important! always cancel raycaster.
					if ( arrow && arrow.parent ) scene.remove( arrow ); // remove arrow helper.

					setTimeout( function(){ 
						document.addEventListener( "keyup", keyupActionEventHandler, false ); 
						document.getElementById("action-buttons").addEventListener( "click", actionButtonsClickHandler );
					}); // important! restore keyup listener.
					p1.animationController.play( "idling" );
				});

				var origin = new THREE.Vector3();
				var direction = new THREE.Vector3();
				var intersectObjects = [ p2.intersectBody, p2.intersectHead ];

				if ( debugMode ) scene.add( arrow );

				(function update(){

					requestAnimationFrameID = requestAnimationFrame( update );

					if ( !isFighting ) { 
						//	cancelAnimationFrame( requestAnimationFrameID );
						p1.animationController.mixer.dispatchEvent({type:"finished"}); 
						return;
					}

					//	raycaster.
					origin.copy( p1.RightHandIndex.position );
					direction.subVectors(
						p1.RightHandSword.position, // direction,
						p1.RightHandIndex.position // origin
					).normalize();  // must be noramlized!
					raycaster.ray.set( origin, direction );

					//	arrow helper.
					if ( arrow && arrow.parent ) { 
						arrow.position.copy( raycaster.ray.origin );
						arrow.setDirection( raycaster.ray.direction  );
					}

					var intersects = raycaster.intersectObjects( intersectObjects ); 
					if ( !intersects.length ) return; // important!

					p2.health -= 1; // p2.health -= (raycaster.far - intersects[0].distance); // (...)/10; or (...)/100;

				//	p2 reaction.
					clearTimeout( reactionInterval );
					reactionInterval = setTimeout( function(){
						debugMode && console.log( p2.name, "reaction:", reaction );

						document.removeEventListener( "keyup", keyupActionEventHandler, false ); // important!
						document.getElementById("action-buttons").removeEventListener( "click", actionButtonsClickHandler );
						p2.animationController.mixer.addEventListener( "finished", function reactionEventHandler(e){
							p2.animationController.mixer.removeEventListener( "finished", reactionEventHandler );
							setTimeout( function(){ 
								document.addEventListener( "keyup", keyupActionEventHandler, false );  // important!
								document.getElementById("action-buttons").addEventListener( "click", actionButtonsClickHandler );
							});
							p2.animationController.play( "idling" ); 
						});

						p2.animationController.motion[ reaction ].reset(); p2.animationController.play( reaction ); 
					}, 100);

				})();

				p1.animationController.motion[ action ].reset(); p1.animationController.play( action ); // p1 action.
				debugMode && console.log( p1.name, "action:", action );

			}

			function showcaseAction( action ){

				document.removeEventListener( "keyup", keyupActionEventHandler, false );
				document.getElementById("action-buttons").removeEventListener( "click", actionButtonsClickHandler );

				var select = document.getElementById("players-droplist");
				var animationController = select.getAnimationController( currentPlayer );

				animationController.mixer.addEventListener( "finished", function raycasterEventHandler(e){
					animationController.mixer.removeEventListener( "finished", raycasterEventHandler );
					setTimeout( function(){ 
						document.addEventListener( "keyup", keyupActionEventHandler, false );  // important! restore keyup listener.
						document.getElementById("action-buttons").addEventListener( "click", actionButtonsClickHandler );
					});
					animationController.play( "idling" );
				});

				if ( isFighting ) { 
					animationController.mixer.dispatchEvent({type:"finished"}); 
					return;
				}

				animationController.motion[ action ].reset(); animationController.play( action );  

			}

		</script>

		<script>

		//	New game.
			
			(function(){

				var intersectHead = new THREE.Mesh(
					new THREE.SphereGeometry( 2, 6, 4 ),
					new THREE.MeshBasicMaterial({color:0xffff00,  wireframe:true})
				); 

				var intersectBody = new THREE.Mesh(
					new THREE.SphereGeometry( 4, 6, 4 ),
					new THREE.MeshBasicMaterial({color:0xffff00,  wireframe:true})
				);

			//	at "/manny/js/three.js" (r96) we comment line 43269: 
			//	"if ( object.visible === false ) return;" to accept 
			//	invisible objects raycasting.

				intersectHead.visible = intersectBody.visible = debugMode;

			//	Health.

				P1 = { 
					health:0, 
					intersectHead: intersectHead.clone(), 
					intersectBody: intersectBody.clone(),
				};

				P2 = { 
					health:0, 
					intersectHead: intersectHead.clone(), 
					intersectBody: intersectBody.clone(),
				};

				(function(){

					var keys = ( "Hips,LeftHand,LeftHandIndex,LeftLeg,LeftFoot,LeftToe,"
					+ "RightHand,RightHandIndex,RightHandSword,RightLeg,RightFoot,RightToe"
					).split(",");

					keys.forEach(function( key ){ 
						P1[ key ] = new THREE.Object3D();  
						P2[ key ] = new THREE.Object3D(); 
					});

				})();

			})();


		//	health bar player 1.

			(function(){

				var bar = document.createElement("div");
				bar.title = "Player1 Health Bar";
				bar.style.cssText = "width:350px;height:40px;position:fixed;top:10px;"
					+ "border:2px solid #fff;border-radius:8px;background-color:#f00;right:380px;";

				var label = document.createElement("span");
				label.textContent = "Player 1";
				label.style.cssText = "position:absolute;color:#fff;"
					+ "font-weight:bold;font-size:x-large;left:-100px;";
				bar.appendChild( label );

				var health_bar = document.createElement("div");
				health_bar.id = "player1-health-bar";
				health_bar.style.cssText = "width:100%;height:100%;"
					+ "background-color:#ff0;float:left;border-radius:4px;";
				bar.appendChild( health_bar );

				var text_bar = document.createElement("div");
				text_bar.style.cssText = "width:100%;text-align:center;background:none;"
					+ "position:absolute;font-weight:bold;color:#fff;font-size:x-large;";
				text_bar.textContent = P1.health+"%";
				bar.appendChild( text_bar );

				P1.appendBar = function(){
					document.body.appendChild( bar );
				};

				P1.removeBar = function(){
					bar.remove();
				};

				P1.healthWacher = function(prop, action, value){
					health_bar.style.width = round( value, 1 ) + "%";
					text_bar.textContent = health_bar.style.width;
					if ( value > 0 ) label.style.color = "#fff";
					else label.style.color = "#f00";
				};

				P1.blink = blink.bind( P1, label );

				watch( P1, "health", P1.healthWacher );

			})();

		//	health bar player 2.

			(function(){

				var bar = document.createElement("div");
				bar.title = "Player2 Health Bar";
				bar.style.cssText = "width:350px;height:40px;position:fixed;top:10px;"
					+ "border:2px solid #fff;border-radius:8px;background-color:#f00;left:10px;";

				var label = document.createElement("span");
				label.textContent = "Player 2";
				label.style.cssText = "position:absolute;color:#fff;"
					+ "font-weight:bold;font-size:x-large;right:-100px";
				bar.appendChild( label );

				var health_bar = document.createElement("div");
				health_bar.id = "player2-health-bar";
				health_bar.style.cssText = "width:100%;height:100%;border-radius:4px;"
					+ "background-color:#ff0;float:right;";
				bar.appendChild( health_bar );

				var text_bar = document.createElement("div");
				text_bar.style.cssText = "width:100%;text-align:center;background:none;"
					+ "position:absolute;font-weight:bold;color:#fff;font-size:x-large;";
				text_bar.textContent = P2.health+"%";
				bar.appendChild( text_bar );

				P2.appendBar = function(){
					document.body.appendChild( bar );
				};

				P2.removeBar = function(){
					bar.remove();
				};

				P2.healthWacher = function(prop, action, value){
					health_bar.style.width = round( value, 1 ) + "%";
					text_bar.textContent = health_bar.style.width;
					if ( value > 0 ) label.style.color = "#fff";
					else label.style.color = "#f00";
				};

				P2.blink = blink.bind( P2, label );

				watch( P2, "health", P2.healthWacher );

			})();

			function blink( label ){
				var display;
				setTimeout( function _blink(){

					if ( isFighting ) {
						label.style.display = "";
						return;
					}

					display = !display;

					if ( display ) 
						label.style.display = "";
					else 
						label.style.display = "none";

					setTimeout( _blink, 650 );

				});
			}

		//	Start game button.

			setTimeout(function(){

				var tab = TabUI.Game.tab;
				var row = document.createElement("div");
				row.style.cssText = "margin:20px 12px 10px;height:35px;text-align:center;";

				var button = document.createElement("div");
				button.id = "start-raycasting";
				button.textContent = "Start Battle";
				button.style.cssText = "max-width:100%;width:100%;height:40px;font-size:large;";
				button.classList.add( "form-control", "btn", "btn-primary", "btn-white-outline", "gradient-btn" );

				button.addEventListener( "click", function(){ 
					button.value = !button.value; 
				});

				button.addEventListener( "click", function(){ 
					document.removeEventListener( "keyup", keyupActionEventHandler, false );
					document.getElementById("action-buttons").removeEventListener( "click", actionButtonsClickHandler );
					setTimeout( function(){ 
						document.addEventListener( "keyup", keyupActionEventHandler, false ); 
						document.getElementById("action-buttons").addEventListener( "click", actionButtonsClickHandler );
					});
				});

				row.appendChild( button );
				tab.appendChild( row );

				watch( button, "value", function showtime(prop, action, value){

					isFighting = value; debugMode && console.log( "isFighting:", isFighting );

					if ( value ) button.textContent = "Pause Battle";
					else if ( !value ) button.textContent = "Start Battle";

					var player1 = scene.getObjectByName( "player1" );
					var player2 = scene.getObjectByName( "player2" );

					var playersDroplist = document.getElementById("players-droplist");
					var animationDroplist = document.getElementById("animation-droplist");

					P1.name = player1.name; P2.name = player2.name;
					P1.skeletonHelper = playersDroplist.getSkeletonHelper("player1");
					P2.skeletonHelper = playersDroplist.getSkeletonHelper("player2");
					P1.animationController = playersDroplist.getAnimationController("player1");
					P2.animationController = playersDroplist.getAnimationController("player2");
					P1.animationController.play( "idling" ); P2.animationController.play( "idling" ); 

					if ( value ) { P1.appendBar();  P2.appendBar(); }

					if ( !value && (P1.health && P2.health) ) {
						button.textContent = "Continue Battle";
					} else if ( !value && !(P1.health && P2.health) ) {
						button.textContent = "New Battle";
					}

					if ( value && !(P1.health && P2.health) ) {
						P1.health = 100; P2.health = 100; // important!
					}

					if ( !isFighting ) {
						P1.animationController.turn(0); 
						P2.animationController.turn(0);
					} else {
						P1.animationController.turn(-Math.PI/2); 
						P2.animationController.turn(Math.PI/2);
					}

				//	stop battle.

					if ( isFighting ) (function update(){

						if ( P1.health < 0 ) {
							P1.health = 0;  
							isFighting = false;
							button.value = false; 
							P2.health && P2.blink();
							setTimeout( function(){
								winner(P2); looser(P1);
							});
							return;

						} else if ( P2.health < 0 ) {
							P2.health = 0; 
							isFighting = false;
							button.value = false; 
							P1.health && P1.blink();
							setTimeout( function(){
								winner(P1); looser(P2);
							});
							return;
						}

						if ( !isFighting ) { 
							if ( P1.health > 0 ) P1.blink();
							if ( P2.health > 0 ) P2.blink();
							return; 
						}

						setTimeout( update, 1000 );

						function winner(p){
							var name = "Aerial 360 Degree Front Side Rotation Kick With Rear Foot";
							p.animationController.motion[ name ].reset();
							p.animationController.play( name );
						}

						function looser(p){
							var name = "Hit In The Shoulder And Falls To The Ground";
							p.animationController.motion[ name ].clampWhenFinished = true;
							p.animationController.motion[ name ].setLoop(THREE.LoopOnce);
							p.animationController.motion[ name ].reset();
							p.animationController.play( name );
						}

					})();

					if ( isFighting ) {
						P1.intersectHead.visible = P1.intersectBody.visible = debugMode;
						P2.intersectHead.visible = P2.intersectBody.visible = debugMode;
					}

					if ( isFighting ) {

						scene.add(P1.intersectHead, P1.intersectBody);
						scene.add(P2.intersectHead, P2.intersectBody);

					} else {

						scene.remove(P1.intersectHead, P1.intersectBody);
						scene.remove(P2.intersectHead, P2.intersectBody);

					}

					if ( isFighting ) {

						updatePointObjects( P1 ); // important!
						updatePointObjects( P2 ); // important!

					}

					
					if ( debugMode ) {
					//	player1.visible = player2.visible = !isFighting; 
					//	P1.skeletonHelper.visible = P2.skeletonHelper.visible = isFighting;
					}


					if ( isFighting ) (function(){

					//	Player 2 (p1).

					//	if ( currentPlayer == "player1" ) var p1 = P2, p2 = P1;
					//	else if ( currentPlayer == "player2" ) var p1 = P1, p2 = P2;

						switch ( currentPlayer ) {

							case "player1": {
								var p1 = P2; 
								var p2 = P1;
							} break;

							case "player2": {
								var p1 = P1; 
								var p2 = P2;
							} break;

							default: {
								var p1 = P2; 
								var p2 = P1;
							} break;

						}

					//	raycaster.
						var origin = new THREE.Vector3();
						var direction = new THREE.Vector3();
						var intersectObjects = [ p2.intersectBody, p2.intersectHead ];
						var raycaster = new THREE.Raycaster(); 
						raycaster.far = 9;

					//	arrow helper.
						var arrow = new THREE.ArrowHelper( 
							raycaster.ray.direction, 
							raycaster.ray.origin, 
							raycaster.far 
						);

						var ignorekeys = [ 
							"Hit Reaction From The Front With Bow",
							"Hit Reaction From The Front With Bow (1)",
							"Hit Reaction From The Front With Bow (2)",
							"Hit In The Shoulder And Falls To The Ground"
						];

						//	var reaction = "Hit Reaction From The Front With Bow (2)";
						//	var reaction = "Hit In The Shoulder And Falls To The Ground";

						var clips = document.getElementById("animation-droplist").getAnimations();

						var names = clips.map(function( clip ){ 
							return clip.name; 
						}).filter( function( name ){
							return !ignorekeys.includes( name );
						});

						(function randomAction(){

							if ( !isFighting ) return;

							var name = names[ parseInt( Math.random() * names.length ) ];
							while ( ignorekeys.includes( name ) ) {
								name = names[ parseInt( Math.random() * names.length ) ];
							}

							p1.animationController.action_queue.unshift( function(){

								if ( !isFighting ) return;

								var reactionInterval;
								var requestAnimationFrameID; // important?

								var reaction;
								switch ( name ) {

									case "great sword slash (2)":
									case "great sword slash (3)":
									case "great sword slash (4)":
									case "great sword slash (5)":
										reaction = "Hit Reaction From The Front With Bow (2)";
									break;

									case "great sword slash":
									case "A Roundhouse Kick To The Side Of An Opponent":
									case "Aerial 360 Degree Front Side Rotation Kick With Rear Foot":
										reaction = "Hit In The Shoulder And Falls To The Ground";
									break;

									default:
										reaction = "Hit Reaction From The Front With Bow (2)";
									break;

								}

								if ( debugMode ) scene.add( arrow );

								p1.animationController.mixer.addEventListener( "finished", function raycasterEventHandler(e){
									p1.animationController.mixer.removeEventListener( "finished", raycasterEventHandler );

									cancelAnimationFrame( requestAnimationFrameID ); // cancel last raycaster update.
									if ( arrow && arrow.parent ) scene.remove( arrow ); // remove last arrow helper.

									p1.animationController.play( "idling" ); // important!
									setTimeout( function(){ p1.animationController.mixer.dispatchEvent({type:"loop"}); });
								});

							//	raycaster update.

								(function update(){

									requestAnimationFrameID = requestAnimationFrame( update );

								//	stop if not fighting.
									if ( !isFighting ) { 
										p1.animationController.mixer.dispatchEvent({type:"finished"}); return; // important!
									}

								//	p1 raycaster.

									origin.copy( p1.RightHandIndex.position );
									direction.subVectors(
										p1.RightHandSword.position, // direction,
										p1.RightHandIndex.position // origin
									).normalize();  // must be noramlized!
									raycaster.ray.set( origin, direction );

								//	p1 arrow.

									if ( arrow && arrow.parent ) { 
										arrow.position.copy( raycaster.ray.origin );
										arrow.setDirection( raycaster.ray.direction  );
									}

								//	p1 intersects.

									var intersects = raycaster.intersectObjects( intersectObjects );

									if ( !intersects.length ) return;

									p2.health -= 1; // p2.health -= (raycaster.far - intersects[0].distance); // (...)/10; or (...)/100;

								//	p2 reaction.
									clearTimeout( reactionInterval );
									reactionInterval = setTimeout( function(){
										debugMode && console.log( p2.name, "reaction:", reaction );
										document.removeEventListener( "keyup", keyupActionEventHandler, false ); // important!
										document.getElementById("action-buttons").removeEventListener( "click", actionButtonsClickHandler );
										p2.animationController.mixer.addEventListener( "finished", function reactionEventHandler(e){
											p2.animationController.mixer.removeEventListener( "finished", reactionEventHandler );
											setTimeout( function(){ 
												document.addEventListener( "keyup", keyupActionEventHandler, false );  // important!
												document.getElementById("action-buttons").addEventListener( "click", actionButtonsClickHandler );
											});
											p2.animationController.play( "idling" ); 
										});
										p2.animationController.motion[ reaction ].reset(); p2.animationController.play( reaction ); 
									}, 100);

								})();

							//	p1 action.
								p1.animationController.motion[ name ].reset(); p1.animationController.play( name ); 
								debugMode && console.log( p1.name, "action:", name );

							}); // end push.

							setTimeout( randomAction, 2500 );

						})(); // end randomAction.

					})(); // end if (isFighting).


				}); // end watch().

			}); // end setTimeout().


			function updatePointObjects( p ){

				var player = scene.getObjectByName( p.name );

				if ( !player ) return;

				var hipsBone = player.getObjectByName("Hips");

				var headBone = player.getObjectByName("Head");
				var bodyBone = player.getObjectByName("Spine");

				var leftlegBone = player.getObjectByName("LeftLeg");
				var leftfootBone = player.getObjectByName("LeftFoot");
				var lefttoeBone = player.getObjectByName("LeftToeBase");
				var lefthandBone = player.getObjectByName("LeftHand");
				var leftindexBone = player.getObjectByName("LeftHandIndex1");

				var rightlegBone = player.getObjectByName("RightLeg");
				var rightfootBone = player.getObjectByName("RightFoot");
				var righttoeBone = player.getObjectByName("RightToeBase");
				var righthandBone = player.getObjectByName("RightHand");
				var rightindexBone = player.getObjectByName("RightHandIndex1");
				var rightswordBone = player.getObjectByName("RightHandIndex1Sword");

				(function update(){
					var requestAnimationFrameID = requestAnimationFrame( update );

					if ( !isFighting ) cancelAnimationFrame( requestAnimationFrameID ); // return; 

					p.intersectHead.position.setFromMatrixPosition(headBone.matrixWorld);
					p.intersectBody.position.setFromMatrixPosition(bodyBone.matrixWorld);
					p.Hips.position.setFromMatrixPosition(hipsBone.matrixWorld);
					p.LeftHand.position.setFromMatrixPosition(lefthandBone.matrixWorld);
					p.LeftHandIndex.position.setFromMatrixPosition(leftindexBone.matrixWorld);
					p.LeftLeg.position.setFromMatrixPosition(leftlegBone.matrixWorld);
					p.LeftFoot.position.setFromMatrixPosition(leftfootBone.matrixWorld);
					p.LeftToe.position.setFromMatrixPosition(lefttoeBone.matrixWorld);
					p.RightLeg.position.setFromMatrixPosition(rightlegBone.matrixWorld);
					p.RightFoot.position.setFromMatrixPosition(rightfootBone.matrixWorld);
					p.RightToe.position.setFromMatrixPosition(righttoeBone.matrixWorld);
					p.RightHand.position.setFromMatrixPosition(righthandBone.matrixWorld);
					p.RightHandIndex.position.setFromMatrixPosition(rightindexBone.matrixWorld);
					p.RightHandSword.position.setFromMatrixPosition(rightswordBone.matrixWorld);

				})();

			} // end updatePointObjects.

		</script>

		<script>

		//	Load Player 1.
			
			(function(name, s, x){

				var loader = new THREE.FBXLoader();
				loader.load( "/manny/characters/MannySwordIdle04.fbx", function( player ){

				//	player is a THREE.Group.

				//	var s = 0.00033; 
					player.name = name; // "player1";
					player.scale.set(s,s,s); // important!
				//	player.position.x = x; // 10;
					scene.add( player );

					(function update(){
						requestAnimationFrame( update );
						player.position.x = playerController.center.x;
						player.position.z = playerController.center.z;
					})();

					var bones = {}; 	// create bone options. TODO!
					var meshes = {};	// create mesh options. TODO!
					var wepons = {};	// create wepon options. TODO!
					var skinned = {};	// create skinned options. TODO!
					var helpers = {};
					var armature; 		// THREE.Group.
					var animations = player.animations;

					player.traverse( function( child ){

						if (child.name == "Armature") { 
							armature = child; 
						}

						if (child.isMesh) {	
							child.castShadow = true;	
							child.receiveShadow = true;	
							meshes[ child.name ] = child;
						}

						if ( child.isBone ) {
							bones[ child.name ] = child;
						}

						if ( child.isSkinnedMesh ) {
							skinned[ child.uuid ] = child;
						}

						if (child.name == "sword") {
							sword1 = child; // debug!
							wepons[ child.name ] = child;
						}

						if (child.name == "MannyTheSkeleton_v51") {
							(function( mesh ){

							//	replace material.
								mesh.material = new THREE.MeshStandardMaterial({
									name:"player1_Material", skinning:true, // important!
								});

								var loader = new THREE.ImageLoader();
								loader.setCrossOrigin("anonymous"); // important!
								var src = "https://i.imgur.com/rxUXS8C.png";
								loader.load( src, function( image ){
									var mapping = THREE.SphericalReflectionMapping;		// important!
									var texture = new THREE.Texture( image, mapping );	// important!
									mesh.material.roughness = 0; 
									mesh.material.metalness = 1; 
									mesh.material.envMap = texture; 
									mesh.material.envMap.needsUpdate = true; 
									mesh.material.needsUpdate = true;
								});

								debugMode && console.log( mesh.material ); 

							//	Create material option. 
								var select = document.getElementById("material-droplist");
								if ( select ) {
									option = document.createElement("option");
									option.text = name;
									option.value = mesh.uuid;
									select.appendChild( option );
								}

							})( child );
						}

					});

				//	Add Sword bone. important!

					(function(){
						var bone = new THREE.Bone();
						bone.name = "RightHandIndex1Sword";
						bone.position.set(200, 20, -80); // importrant!
						player.getObjectByName("RightHandIndex1").add(bone);
					})();

				//	Skeleton helper (for debug).

					(function(){
						var skeletonHelper = new THREE.SkeletonHelper( player );
						skeletonHelper.visible = false; // debugMode;
						scene.add( skeletonHelper );
						helpers.skeletonHelper = skeletonHelper;
						debugMode && console.log( skeletonHelper );
					})();

				//	characters contains only idle animation.
					if ( animations && animations.length ) player.animations[0].name = "idling";

				//	Animation controller.
					var animationController = new MW.AnimationController( player );

				//	play idling.
					if ( animationController.motion.idling ) animationController.play("idling");

				//	keyInputControls.addEventListener( "movekeychange", function () { 
				//		animationController.turn( keyInputControls.frontAngle + Math.PI );
				//	});

				//	action queue.
					animationController.action_queue = []; // important!
					animationController.mixer.addEventListener( "loop", function(e){
						if ( !isFighting ) return;
						var faction = animationController.action_queue.shift(); 
						if ( faction ) faction();
					});

				//	bind animations.
					(function( select ){
						var mixer = animationController.mixer; 
						var object = animationController.object;
						select.getAnimations().forEach(function( clip ){
							var clipAction = mixer.clipAction( clip, object );
							animationController.motion[ clip.name ] = clipAction;
							animationController.motion[ clip.name ].setLoop(THREE.LoopOnce);
							animationController.motion[ clip.name ].clampWhenFinished = true;
						});
					})( document.getElementById("animation-droplist") );

				//	start updating.
					var clock = new THREE.Clock();
					(function update(){
						requestAnimationFrame( update );
						var delta = clock.getDelta();
						animationController.update( delta );
					})();

				//	Players droplist.
					(function( select ){
						if ( !select ) return;

						var object = {
							name: player.name,
							uuid: player.uuid, // THREE.Math.generateUUID(),
						};

						if ( animationController ) {
							object.animationController = animationController;
						}

						if ( helpers.skeletonHelper ) {
							object.skeletonHelper = helpers.skeletonHelper;
						}

						select.addPlayer( player.name, object, true);
					})( document.getElementById("players-droplist") );

				},

				function(e){}, 
				function(err){
					console.error(err);
				});

			})("player1", 0.00033, 10);


		</script>

		<script>

		//	Load Player.

			loadPlayer( "player2", 0.00033, -10 );

			function loadPlayer(name, s, x){

				var loader = new THREE.FBXLoader();
				loader.load( "/manny/characters/MannySwordIdle05.fbx", function( player ){

				//	player is a THREE.Group.

				//	var s = 0.00033; 
					player.name = name; // "player1";
					player.scale.set(s,s,s); // important!
					player.position.x = x;
					scene.add( player );

					var bones = {}; 	// create bone options. TODO!
					var meshes = {};	// create mesh options. TODO!
					var wepons = {};	// create wepon options. TODO!
					var skinned = {};	// create skinned options. TODO!
					var helpers = {};
					var armature; 		// THREE.Group.
					var animations = player.animations;

					player.traverse( function( child ){

						if (child.name == "Armature") { 
							armature = child; 
						}

						if (child.isMesh) {	
							child.castShadow = true;	
							child.receiveShadow = true;	
							meshes[ child.name ] = child;
						}

						if ( child.isBone ) {
							bones[ child.name ] = child;
						}

						if ( child.isSkinnedMesh ) {
							skinned[ child.uuid ] = child;
						}

						if (child.name == "sword") {
							sword1 = child; // debug!
							wepons[ child.name ] = child;
						}

						if (child.name == "MannyTheSkeleton_v51") {
							(function(mesh){

							//	replace material.
								mesh.material = new THREE.MeshStandardMaterial({
									name:"player1_Material", skinning:true, // important!
								});

								var loader = new THREE.ImageLoader();
								loader.setCrossOrigin("anonymous"); // important!
								var src = "https://i.imgur.com/Fx9154f.png";
								loader.load( src, function( image ){
									var mapping = THREE.SphericalReflectionMapping;		// important!
									var texture = new THREE.Texture( image, mapping );	// important!
									mesh.material.roughness = 0; 
									mesh.material.metalness = 1; 
									mesh.material.envMap = texture; 
									mesh.material.envMap.needsUpdate = true; 
									mesh.material.needsUpdate = true;
								});

								debugMode && console.log( mesh.material ); 

							//	Create material option. 
								var select = document.getElementById("material-droplist");
								if ( select ) {
									option = document.createElement("option");
									option.text = name;
									option.value = mesh.uuid;
									select.appendChild( option );
								}

							})( child );
						}

					});

				//	Add Sword bone. important!

					(function(){
						var bone = new THREE.Bone();
						bone.name = "RightHandIndex1Sword";
						bone.position.set(200, 20, -80); // importrant!
						player.getObjectByName("RightHandIndex1").add(bone);
					})();

				//	Skeleton helper (for debug).

					(function(){
						var skeletonHelper = new THREE.SkeletonHelper( player );
						skeletonHelper.visible = false; // debugMode;
						scene.add( skeletonHelper );
						helpers.skeletonHelper = skeletonHelper;
						debugMode && console.log( skeletonHelper );
					})();

				//	characters contains only idle animation.
					if ( animations && animations.length ) player.animations[0].name = "idling";

				//	Animation controller.
					var animationController = new MW.AnimationController( player );

				//	play idling.
					if ( animationController.motion.idling ) animationController.play("idling");

				/*
					(function(){

					//	raycaster.
						var origin = new THREE.Vector3();
						var direction = new THREE.Vector3();
						var intersectObjects = [ P1.intersectBody, P1.intersectHead ];
						var raycaster = new THREE.Raycaster(); 
						raycaster.far = 9;

					//	arrow helper.
						var arrow = new THREE.ArrowHelper( 
							raycaster.ray.direction, 
							raycaster.ray.origin, 
							raycaster.far 
						);

					})();
				*/

				//	action queue.
					animationController.action_queue = []; // important!
					animationController.mixer.addEventListener( "loop", function(e){
						if ( !isFighting ) return;
						var faction = animationController.action_queue.shift(); faction && faction();
					});

				//	bind animations.
					(function( select ){
						var mixer = animationController.mixer; 
						var object = animationController.object;
						select.getAnimations().forEach(function( clip ){
							var clipAction = mixer.clipAction( clip, object );
							animationController.motion[ clip.name ] = clipAction;
							animationController.motion[ clip.name ].setLoop(THREE.LoopOnce);
							animationController.motion[ clip.name ].clampWhenFinished = true;
						});
					})( document.getElementById("animation-droplist") );

				//	start updating.
					var clock = new THREE.Clock();
					(function update(){
						requestAnimationFrame( update );
						var delta = clock.getDelta();
						animationController.update( delta );
					})();

				//	Players droplist.
					(function( select ){
						if ( !select ) return;

						var object = {
							name: player.name,
							uuid: player.uuid, // THREE.Math.generateUUID(),
						};

						if ( animationController ) {
							object.animationController = animationController;
						}

						if ( helpers.skeletonHelper ) {
							object.skeletonHelper = helpers.skeletonHelper;
						}

						select.addPlayer( player.name, object );
					})( document.getElementById("players-droplist") );

				},

				function(e){}, 
				function(err){
					console.error(err);
				});

			}

		</script>

		<script>

/*
			function raycasting( action, reaction ){

				var idleInterval;
				var reactionInterval;
				var requestAnimationFrameID; // important?

				var select = document.getElementById("players-droplist");
				var animationController = select.getAnimationController( currentPlayer );

				if ( currentPlayer == "player1" ) var p1 = P1, p2 = P2;
				else if ( currentPlayer == "player2" ) var p1 = P2, p2 = P1;

				//	raycaster.
				var raycaster = new THREE.Raycaster(); 
				raycaster.far = 9;
				var origin = new THREE.Vector3();
				var direction = new THREE.Vector3();
				var intersectObjects = [ p2.intersectBody, p2.intersectHead ];

				//	arrow helper.
				var arrow = new THREE.ArrowHelper( 
					raycaster.ray.direction, 
					raycaster.ray.origin, 
					raycaster.far 
				);

				if ( debugMode ) scene.add( arrow );

				animationController.mixer.addEventListener( "finished", function raycasterEventHandler(e){
					animationController.mixer.removeEventListener( "finished", raycasterEventHandler );
					document.addEventListener( "keyup", keyupActionEventHandler, false );
					cancelAnimationFrame( requestAnimationFrameID ); // cancel last raycaster update.
					if ( arrow && arrow.parent ) scene.remove( arrow ); // remove last arrow helper.
					animationController.mixer.dispatchEvent({type:"loop"}); // important!
				});

				(function update(){

					requestAnimationFrameID = requestAnimationFrame( update );

					//	stop if not fighting.
					if ( !isFighting ) { 
						animationController.mixer.dispatchEvent({type:"finished"});  // important!
						return;
					}

					//	p1 raycaster.
					origin.copy( p1.RightHandIndex.position );
					direction.subVectors(
						p1.RightHandSword.position, // direction,
						p1.RightHandIndex.position // origin
					).normalize();  // must be noramlized!
					raycaster.ray.set( origin, direction );

					//	p1 arrow.
					if ( arrow && arrow.parent ) { 
						arrow.position.copy( raycaster.ray.origin );
						arrow.setDirection( raycaster.ray.direction  );
					}

					//	p1 intersects.
					var intersects = raycaster.intersectObjects( intersectObjects );

					if ( !intersects.length ) {
						clearTimeout( idleInterval );
						idleInterval = setTimeout( function(){
							animationController.play( "idling" ); 
						}, 100);
						return; // important!
					}

					p2.health -= 1; // p2.health -= (raycaster.far - intersects[0].distance); // (...)/10; or (...)/100;

					//	p2 reaction.
					clearTimeout( reactionInterval );
					reactionInterval = setTimeout( function(){
						p2.animationController.mixer.addEventListener( "finished", function reactionEventHandler(e){
							p2.animationController.mixer.removeEventListener( "finished", reactionEventHandler );
							p2.animationController.play( "idling" ); 
						});
						p2.animationController.motion[ reaction ].reset(); 
						p2.animationController.play( reaction ); 
						debugMode && console.log( p2.name+":", reaction );
					}, 100);

				})();

				//	p1 action.
				animationController.motion[ action ].reset();
				animationController.play( action ); 
				debugMode && console.log( p1.name+":", action );

			}
*/

/*
			function randomStartUpAction( p ){

				if ( !isFighting ) return;

				var ignorekeys = [ 
					"Hit Reaction From The Front With Bow",
					"Hit Reaction From The Front With Bow (1)",
					"Hit Reaction From The Front With Bow (2)",
					"Hit In The Shoulder And Falls To The Ground"
				];

			//	var reaction = "Hit Reaction From The Front With Bow (2)";
			//	var reaction = "Hit In The Shoulder And Falls To The Ground";

				var clips = document.getElementById("animation-droplist").getAnimations();

				var names = clips.map(function( clip ){ 
					return clip.name; 
				}).filter( function( name ){
					return !ignorekeys.includes( name );
				});

				if ( !p.animationController.action_queue.length ) {
					
					update();

				} else {

					setTimeout( update, 3000 );

					p.animationController.mixer.dispatchEvent({type:"finished"}); // important!
				}

				function update(){

					if ( !isFighting ) return;

					var name = names[ parseInt( Math.random() * names.length ) ];
					while ( ignorekeys.includes( name ) ) {
						name = names[ parseInt( Math.random() * names.length ) ];
					}

				//	send a delayed "finished" event if "action_queue" is empty. hack!
					if ( !p.animationController.action_queue.length ) setTimeout(function(){
						p.animationController.mixer.dispatchEvent({type:"finished"}); // important!
					}, 100);

					p.animationController.action_queue.push( name );

					if ( isFighting ) setTimeout( update, 3000 );

				}

			}
*/

/*
				//	( isFighting )

					button.addEventListener( "click", function clickHandler(){

						if ( !isFighting ) return;

						var select = document.getElementById("players-droplist");
						var animationController = select.getAnimationController( currentPlayer );
						animationController.action_queue.unshift( raycasting.bind(null, clip.name, reaction ) );

					});

				//	( !isFighting )

					button.addEventListener( "click", function clickHandler(){

						if ( isFighting ) return;

						var select = document.getElementById("players-droplist");
						var animationController = select.getAnimationController( currentPlayer );

						button.removeEventListener( "click", clickHandler );

						animationController.mixer.addEventListener( "finished", function actionEventHandler(e){
							setTimeout( function(){ button.addEventListener( "click", clickHandler ); });
							animationController.mixer.removeEventListener( "finished", actionEventHandler );
							animationController.play( "idling" );
						});

						animationController.motion[ clip.name ].reset(); animationController.play( clip.name ); 

					});

*/


/*
				//	raycaster player 1.

					(function raycaster(){

						var requestAnimationFrameID; // important?
						var reaction = "Hit Reaction From The Front With Bow (2)";

					//	raycaster.
						var origin = new THREE.Vector3();
						var direction = new THREE.Vector3();
						var intersectObjects = [ P2.intersectBody, P2.intersectHead ];
						var raycaster = new THREE.Raycaster(); 
						raycaster.far = 9;

						var arrow = new THREE.ArrowHelper( 
							raycaster.ray.direction, 
							raycaster.ray.origin, 
							raycaster.far 
						);

						animationController.mixer.addEventListener( "finished", function(e){

							cancelAnimationFrame( requestAnimationFrameID ); // cancel last raycaster update.
							if ( arrow && arrow.parent ) scene.remove( arrow ); // remove last arrow helper.

							if ( !isFighting ) return;

							if ( !animationController.action_queue.length ) {
								animationController.play( "idling" ); return;
							}

						//	starting next action.

							if ( debugMode ) scene.add( arrow );

						//	raycaster update.
							(function update(){

								requestAnimationFrameID = requestAnimationFrame( update );

							//	stop if not fighting.
								if ( !isFighting ) {
									cancelAnimationFrame( requestAnimationFrameID );
									if ( arrow && arrow.parent ) scene.remove( arrow );
									return;
								}

								origin.copy( P1.RightHandIndex.position );

								direction.subVectors(
									P1.RightHandSword.position, // direction,
									P1.RightHandIndex.position // origin
								).normalize();  // must be noramlized!

								raycaster.ray.set( origin, direction );


							//	arrow helper.
								if ( arrow && arrow.parent ) { 
									arrow.position.copy( raycaster.ray.origin );
									arrow.setDirection( raycaster.ray.direction  );
								}

								var intersects = raycaster.intersectObjects( intersectObjects );

								if ( !intersects.length ) return;

							//	stop if hit intersects.
								cancelAnimationFrame( requestAnimationFrameID ); // important!
							//	if ( arrow && arrow.parent ) scene.remove( arrow ); 

							//	player 2 reaction.
								P2.animationController.play( reaction ); 
								P2.animationController.motion[ reaction ].reset(); 
								debugMode && console.log( "reaction player 2:", reaction );

							//	player 2 health.
								P2.health -= (raycaster.far - intersects[0].distance); // (...)/10; or (...)/100;

							})();

						//	player 1 action.
							var key = animationController.action_queue.shift();
							animationController.play( key ); 
							animationController.motion[ key ].reset();
							debugMode && console.log( "player 1:", key );

						}); // end raycasterEventHandler.

					})(); // end raycaster player 1.
*/

/*
				//	raycaster player 2.

					(function raycaster(){

						var requestAnimationFrameID; // important?
						var reaction = "Hit Reaction From The Front With Bow (2)";

					//	raycaster.
						var origin = new THREE.Vector3();
						var direction = new THREE.Vector3();
						var intersectObjects = [ P1.intersectBody, P1.intersectHead ];
						var raycaster = new THREE.Raycaster(); 
						raycaster.far = 9;

						var arrow = new THREE.ArrowHelper( 
							raycaster.ray.direction, 
							raycaster.ray.origin, 
							raycaster.far 
						);

						animationController.mixer.addEventListener( "finished", function raycasterEventHandler(e){

							cancelAnimationFrame( requestAnimationFrameID ); // cancel last raycaster update.
							if ( arrow && arrow.parent ) scene.remove( arrow ); // remove last arrow helper.

							if ( !isFighting ) return;

							if ( !animationController.action_queue.length ) {
								animationController.play( "idling" ); return;
							}

						//	starting next action.

							if ( debugMode ) scene.add( arrow );

						//	raycaster update.
							(function update(){

								requestAnimationFrameID = requestAnimationFrame( update );

							//	stop if not fighting.
								if ( !isFighting ) {
									cancelAnimationFrame( requestAnimationFrameID );
									if ( arrow && arrow.parent ) scene.remove( arrow );
									return;
								}

								origin.copy( P2.RightHandIndex.position );

								direction.subVectors(
									P2.RightHandSword.position, // direction,
									P2.RightHandIndex.position // origin
								).normalize();  // must be noramlized!

								raycaster.ray.set( origin, direction );

							//	arrow helper.
								if ( arrow && arrow.parent ) { 
									arrow.position.copy( raycaster.ray.origin );
									arrow.setDirection( raycaster.ray.direction  );
								}

								var intersects = raycaster.intersectObjects( intersectObjects );

								if ( !intersects.length ) return;

							//	stop raycasting if hit intersects?
								cancelAnimationFrame( requestAnimationFrameID ); // important!
							//	if ( arrow && arrow.parent ) scene.remove( arrow ); 

							//	player 1 reaction.
								P1.animationController.play( reaction ); 
								P1.animationController.motion[ reaction ].reset(); 
								debugMode && console.log( "reaction player 1:", reaction );

							//	player 1 health.
								P1.health -= (raycaster.far - intersects[0].distance); // (...)/10; or (...)/100;

							})();

						//	player 2 action.
							var key = animationController.action_queue.shift();
							animationController.play( key ); 
							animationController.motion[ key ].reset();
							debugMode && console.log( "player 2:", key );

						}); // end raycasterEventHandler.

					})(); // end raycaster player 2.
*/

/*
				//	this is going to "finished" event handler.
					button.addEventListener( "click", function clickHandler(){
						
						button.removeEventListener( "click", clickHandler );

						var p1, p2;
						if ( currentPlayer == "player1" ) { p1 = P1; p2 = P2; }
						if ( currentPlayer == "player2" ) { p1 = P2; p2 = P1; }

						var requestAnimationFrameID; // important!
						var select = document.getElementById("players-droplist");
						var animationController = select.getAnimationController( currentPlayer );
					//	animationController.mixer.dispatchEvent({type:"finished"}); // important?

						if ( isFighting ){

							var origin = new THREE.Vector3();
							var direction = new THREE.Vector3();
							var intersectObjects = [p2.intersectBody, p2.intersectHead];
							var raycaster = new THREE.Raycaster(); raycaster.far = 9;

						//	Arrow helper.
							var arrow = new THREE.ArrowHelper( 
								raycaster.ray.direction, raycaster.ray.origin, raycaster.far 
							); if ( debugMode ) scene.add( arrow );

							(function update(){

								requestAnimationFrameID = requestAnimationFrame( update );

								origin.copy( p1.RightHandIndex.position );

								direction.subVectors(
									p1.RightHandSword.position, // direction,
									p1.RightHandIndex.position // origin
								).normalize();  // must be noramlized!

								raycaster.ray.set( origin, direction );

							//	Arrow helper.
								if ( arrow && arrow.parent ) { 
									arrow.position.copy( raycaster.ray.origin );
									arrow.setDirection( raycaster.ray.direction  );
								}

								var intersects = raycaster.intersectObjects( intersectObjects );

								if ( !intersects.length ) return;

								cancelAnimationFrame( requestAnimationFrameID ); // important!
								p2.health -= (raycaster.far - intersects[0].distance); // (...)/10; or (...)/100;
								p2.animationController.play( reaction ); 
								p2.animationController.motion[ reaction ].reset();

							})();

						} // end if (isFighting)

						animationController.mixer.addEventListener( "finished", function finishedEventHandler(e){

							cancelAnimationFrame( requestAnimationFrameID ); // important!

							setTimeout( function(){ 
								animationController.mixer.removeEventListener( "finished", finishedEventHandler ); // important!
								debugMode && console.log( clip.name, "finished:", e );
							});

							setTimeout( function(){ 
								button.addEventListener( "click", clickHandler ); 
								debugMode && console.log( clip.name, "button is ready." );
							});

							scene.remove( arrow );

							animationController.play( "idling" );
						});

						animationController.play( clip.name ); 
						animationController.motion[ clip.name ].reset();

					});
*/

/*
						var requestAnimationFrameID; // important!

						var origin = new THREE.Vector3();
						var direction = new THREE.Vector3();
						var intersectObjects = [p2.intersectBody, p2.intersectHead];
						var raycaster = new THREE.Raycaster(); raycaster.far = 9;

						var arrow = new THREE.ArrowHelper( raycaster.ray.direction, raycaster.ray.origin, raycaster.far );

						animationController.mixer.addEventListener( "finished", onfinishedEventHandler );
						if ( !isFighting ) animationController.mixer.removeEventListener( "finished", onfinishedEventHandler );

						setTimeout( function(){
							if ( debugMode ) scene.add( arrow );
							animationController.mixer.dispatchEvent({type:"finished"});
						}, 3000);


						function onfinishedEventHandler( e ){

							cancelAnimationFrame( requestAnimationFrameID ); // important!

							if ( !isFighting ) {
								if (arrow && arrow.parent) scene.remove( arrow );
								cancelAnimationFrame( requestAnimationFrameID ); // important!
								this.removeEventListener( "finished", onfinishedEventHandler );
								return;
							}

							var name = names[ parseInt( Math.random() * names.length ) ];
							while ( ignorekeys.includes( name ) ) {
								name = names[ parseInt( Math.random() * names.length ) ];
							}

							(function update(){

								requestAnimationFrameID = requestAnimationFrame( update );

								origin.copy( p1.RightHandIndex.position );

								direction.subVectors(
									p1.RightHandSword.position, // direction,
									p1.RightHandIndex.position // origin
								).normalize();  // must be noramlized!

								raycaster.ray.set( origin, direction );

								//	Arrow helper.
								if ( arrow && arrow.parent ) { 
									if ( !isFighting ) scene.remove( arrow );
									arrow.position.copy( raycaster.ray.origin );
									arrow.setDirection( raycaster.ray.direction  );
								}

								var intersects = raycaster.intersectObjects( intersectObjects );

								if ( !intersects.length ) return;

								cancelAnimationFrame( requestAnimationFrameID ); // important!

								p2.health -= (raycaster.far - intersects[0].distance); // (...)/10; or (...)/100;
								p2.animationController.play( reaction );
								p2.animationController.motion[ reaction ].reset();

							})();

							animationController.play( name ); animationController.motion[ name ].reset();

						} // end onfinishedEventHandler.

*/

/*
				//	raycaster event listener.
					animationController.mixer.addEventListener( "finished", function raycastEventHandler(e){

						var p1 = P1, p2 = P2; // important!
						var requestAnimationFrameID; // important?
						var reaction = "Hit Reaction From The Front With Bow (2)";

						if ( !isFighting ) return;

						if ( !animationController.action_queue.length ) { 
							animationController.play( "idling" ); return; 
						}
						
					//	raycaster.
						var origin = new THREE.Vector3();
						var direction = new THREE.Vector3();
						var intersectObjects = [ p2.intersectBody, p2.intersectHead ];
						var raycaster = new THREE.Raycaster(); 
						raycaster.far = 9;

						var arrow;
						if ( debugMode ) {
							arrow = new THREE.ArrowHelper( 
								raycaster.ray.direction, 
								raycaster.ray.origin, 
								raycaster.far 
							);
							scene.add( arrow );
						}

					//	animationController.mixer.addEventListener( "finished", function actionfinishedEventHandler(e){
					//		animationController.mixer.removeEventListener( "finished", actionfinishedEventHandler );
					//		cancelAnimationFrame( requestAnimationFrameID ); // important!
					//		if ( arrow && arrow.parent ) scene.remove( arrow ); 
					//	});

					//	raycast update.
						(function update(){

							requestAnimationFrameID = requestAnimationFrame( update );
							debugMode && console.log( requestAnimationFrameID );

							if ( !isFighting ) {
								cancelAnimationFrame( requestAnimationFrameID );
								if ( arrow && arrow.parent ) scene.remove( arrow );
							}

							origin.copy( p1.RightHandIndex.position );

							direction.subVectors(
								p1.RightHandSword.position, // direction,
								p1.RightHandIndex.position // origin
							).normalize();  // must be noramlized!

							raycaster.ray.set( origin, direction );

						//	arrow helper.
							if ( arrow && arrow.parent ) { 
								arrow.position.copy( raycaster.ray.origin );
								arrow.setDirection( raycaster.ray.direction  );
							}

							var intersects = raycaster.intersectObjects( intersectObjects );

							if ( !intersects.length ) return;

							cancelAnimationFrame( requestAnimationFrameID ); // important!
						//	if ( arrow && arrow.parent ) scene.remove( arrow ); 

							p2.health -= (raycaster.far - intersects[0].distance); // (...)/10; or (...)/100;
							p2.animationController.action_queue.unshift( reaction );
							p2.animationController.mixer.dispatchEvent({type:"finished"});

						})();

					//	play action.
						var key = animationController.action_queue.shift();
						animationController.play( key );
						animationController.motion[ key ].reset();

					});
*/
		</script>
	</body>
</html>
