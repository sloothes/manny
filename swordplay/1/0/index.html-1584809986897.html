<!DOCTYPE html>
<html lang="en">
	<head>

		<title>mannyTheSkeleton: Swordplay (beta 1.0)</title>

		<meta charset="utf-8">
		<meta name="generator" content="HTML-Editor">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">

		<link rel="stylesheet" href="/css/joystick.css">
		<link rel="stylesheet" href="/css/bootstrap.min.css">
		<link rel="stylesheet" href="/css/bootbox-dialoges.css">

		<script src="/js/watch.js"></script>
		<script src="/js/jquery.min.js"></script> 
		<script src="/js/system.min.js"></script>
		<script src="/js/signals.min.js"></script>
		<script src="/js/inflate.min.js"></script>
		<script src="/js/zangodb.min.js"></script>
		<script src="/js/bootstrap.min.js"></script>
		<script src="/js/hold-event.min.js"></script>

		<style>

			body {
				font-family: sans-serif;
				font-size: 13px;
				background-color: #000;
				margin: 0px;
				overflow: hidden;
			}

			#loading-bar {
				width:100%;
				height:100%;
				top:0; left:0;
				position:fixed;
				display:flex;
				align-items:center;
				justify-content:center;
			}

			.middle > * {
				top:0; 
				left:0;
				right:0;
				bottom:0;
				margin:auto;"
				position:absolute;
			}

			#joystick1 {
				right: calc(40px + 370px);
			}
			
			#jumpButton {
				right: calc(105px + 370px);
			}

			.btn-action {
				padding:0;
				width:55px;
				height:55px;
				border:1px solid;
				border-radius:4px;
				margin-right:4px;
				margin-bottom:4px;
				display:inline-block;
			}
			
			.btn-action + .btn-action {
				margin-right:4px;
			}

		</style>
	</head>

	<body ontouchstart="">

		<script src="/manny/js/three.js"></script>
		<script src="/manny/js/TabUI.js"></script>
		<script src="/manny/js/MeshWalk.js"></script>
		<script src="/manny/js/UVsDebug.js"></script>
		<script src="/manny/js/FBXLoader.js"></script>
		<script src="/manny/js/VirtualInput.js"></script>
		<script src="/manny/js/EditorControls.js"></script>
		<script src="/manny/js/camera-controls.js"></script>
		<script src="/manny/js/SubdivisionModifier.js"></script>
		<script src="/manny/js/three-pathfinding.umd.js"></script>
		<script src="/threejs/r96/examples/js/loaders/GLTFLoader.js"></script>
		<script src="/threejs/r96/examples/js/exporters/GLTFExporter.js"></script>
		<script src="/threejs/r96/examples/js/exporters/STLExporter.js"></script>
		<script src="/threejs/r96/examples/js/exporters/OBJExporter.js"></script>
		<script src="/threejs/r96/examples/js/exporters/ColladaExporter.js"></script>

		<script>

			debugMode = true; // important!
			MW.install( THREE ); // important!

		//	CameraControls.install( {THREE:THREE} ); // demo!
		//	THREE.Pathfinding = threePathfinding.Pathfinding;
		//	THREE.PathfindingHelper = threePathfinding.PathfindingHelper;
		//	IMPORTANT NOTE: at "/manny/js/three.js" (r96),
		//	we comment line 43269: "// if ( object.visible === false ) return;"

			Number.prototype.format = function (){
				return this.toString().replace(/(\d)(?=(\d{3})+(?!\d))/g, "$1,");
			};

			function round(number, precision) {
				var shift = function (number, precision, reverseShift) {
					if (reverseShift) {
						precision = -precision;
					}  
					numArray = ("" + number).split("e");
					return +(numArray[0] + "e" + (numArray[1] ? (+numArray[1] + precision) : precision));
				};
				return shift(Math.round(shift(number, precision, false)), precision, true);
			}

		</script>

		<script>

			(function(){

			//	const w = 370; // important!

			//	Scene.
				scene = new THREE.Scene();

			//	Camera.
				(function(){

					var aspect = (window.innerWidth - 370) / window.innerHeight;
					camera = new THREE.PerspectiveCamera( 50, aspect, 1, 100000 );
					camera.position.set(0, 5, 25);

				})();

			//  Camera Light.
				(function(){

					cameraLight = new THREE.DirectionalLight( 0xdfebff, 0.75 );
					cameraLight.position.set( 0, 500, 300 );
					cameraLight.castShadow = true;
					cameraLight.shadow.mapSize.width  = Math.pow(2, 10); // 2048;
					cameraLight.shadow.mapSize.height = Math.pow(2, 10); // 2048;

					var d = 30;
					cameraLight.shadow.camera.left = - d;
					cameraLight.shadow.camera.right = d;
					cameraLight.shadow.camera.top = d;
					cameraLight.shadow.camera.bottom = - d;
					cameraLight.shadow.camera.far = 10000;

					shadowHelper = new THREE.CameraHelper(cameraLight.shadow.camera);
					shadowHelper.visible = false;

					scene.add( cameraLight, shadowHelper  );

					(function update(){
						requestAnimationFrame( update );
						cameraLight.position.copy( camera.position );
					})();

				})();

			//  Renderer.
				(function(){

					renderer = new THREE.WebGLRenderer({
						antialias: true,
						preserveDrawingBuffer: true,
					});

					renderer.gammaInput = true;
					renderer.gammaOutput = true;
					renderer.shadowMap.enabled = true;
					renderer.setClearColor( 0x000000 );
					renderer.setPixelRatio( window.devicePixelRatio );
					renderer.setSize( (window.innerWidth - 370), window.innerHeight );
					document.body.appendChild( renderer.domElement );

					window.addEventListener("resize", function onWindowResize() {
						renderer.setSize( (window.innerWidth - 370), window.innerHeight );
					});

					window.addEventListener("resize", function onWindowResize() {
						camera.aspect = renderer.domElement.clientWidth / renderer.domElement.clientHeight;
						camera.updateProjectionMatrix();
					});

					mouse = new THREE.Vector2();

					renderer.domElement.addEventListener("mousemove", function(e) {
						mouse.x = ( e.clientX / this.clientWidth ) * 2 - 1;
						mouse.y = - ( e.clientY / this.clientHeight ) * 2 + 1;
					});

					(function render(){
						requestAnimationFrame( render );
						renderer.render( scene, camera );
					})();

				})();

			//	Editor Controls.
				setTimeout(function(){
					controls = new THREE.EditorControls(camera, renderer.domElement);
					controls.center.set(0, 10, 0);
					camera.lookAt(controls.center); // important!
				});

			})();

		//	World - Octree.

			(function(){

				world = new MW.World();

				var x = 1500, y = 1500, z = 1500;
				var min = new THREE.Vector3( -x, -y, -z );
				var max = new THREE.Vector3(  x,  y,  z );
				var partition = 1; // nodes: Math.pow( 8, partition )

				octree = new MW.Octree( min, max, partition );
				world.add( octree );

				var clock = new THREE.Clock();

				(function update(){
					requestAnimationFrame( update );
					var delta = clock.getDelta();
					var elapsed = clock.getElapsedTime();
					world.step( Math.min( delta, 0.02 ) );
					scene.updateMatrixWorld(); // important!
				})();

			})();

			(function(){

			//	ground.
				ground = new THREE.Mesh(
					new THREE.PlaneGeometry( 3000, 3000, 1, 1 ).rotateX(-Math.PI/2),
					new THREE.MeshLambertMaterial({ 
						opacity:1, 
						color:0x829ec4,
					})
				);

			//	We need only the geometry of the ground
			//	so there is not need to add to the scene.
			//	ground.rotation.x = -Math.PI / 2;
				octree.importThreeMesh( ground ); // important!
			//	scene.add( ground ); // optional!

			//	Ground Helper.
				groundHelper = new THREE.GridHelper( 3000, 300, 0x444444, 0x444444 );
				scene.add( groundHelper );

			//	Ground Raycaster.
				setTimeout(function(){
					var raycaster = new THREE.Raycaster();
					var intersecthelper = new THREE.Mesh(
						new THREE.CircleBufferGeometry( 2, 32 ).rotateX(-Math.PI/2),
						new THREE.MeshBasicMaterial({color:0xffff00, wireframe:false})
					);
					renderer.domElement.addEventListener("mousemove", function(e) {
						camera.updateMatrixWorld(); // important!
						raycaster.setFromCamera( mouse, camera );
						var intersects = raycaster.intersectObject( ground );
						if ( !intersects.length ) return;
						intersecthelper.position.copy( intersects[0].point );
					});
					intersecthelper.visible = debugMode;
					scene.add( intersecthelper );
				});

			})();


		</script>

		<script>

		//	TabUI

			(function(){

				var sidePanel = createSidePanel();
				var gameTab = TabUI.add( "Game", "game-tab" );
				var debugTab = TabUI.add( "Debug", "debug-tab" );
				var playersTab = TabUI.add( "Players", "player-tab" );
				var animationsTab = TabUI.add( "Animations", "animation-tab" );

			//	var loginTab = TabUI.add( "Login", "login-tab" );
			//	var weponTab = TabUI.add( "Wepon", "wepon-tab" );
			//	var levelTab = TabUI.add( "Levels", "level-tab" );
			//	var cameraTab = TabUI.add( "Camera", "camera-tab" );
			//	var actionTab = TabUI.add( "Actions", "action-tab" );
			//	var controlTab = TabUI.add( "Controls", "control-tab" );
			//	var materialTab = TabUI.add( "Material", "material-tab" );

				document.body.appendChild( sidePanel );
				TabUI.append( "Game", "Animations", "Players" );
				TabUI.Game.role.classList.add("active");
				TabUI.Game.tab.classList.add("in","active");

			})();

		</script>

		<script>

		//	Games tab.

			(function(){

			//	Players droplist.

				var players = {}; // local.
				currentPlayer = "player1"; // global.

				var tab = TabUI.Game.tab;
				var row = document.createElement("h3");
				row.style.cssText = "padding-right:16px;";
				row.textContent = "Player:";

				var select = document.createElement("select");
				select.id = "players-droplist";
				select.style.cssText = "width:180px;color:#000;float:right;"
				+ "border:1px solid;border-radius:4px;padding:2px 4px 4px 4px;"
				+ "font-size:20px;margin-left:10px;";
				
				select.addEventListener( "change", function(){
					currentPlayer = this.value;
				});

				select.addPlayer = function( key, object, selected ){
					if ( !( key && object ) ) return;
					players[ key ] = object;
					var option = document.createElement("option");
					option.text = option.value = key;
					if ( selected ) {
						currentPlayer = option.value;
						option.setAttribute("selected", "");
					}
					select.appendChild( option );
				};

				select.getPlayer = function( key ){
					if ( key ) return players[ key ];
					return players[ this.value ];
				};

				select.getAnimationController = function( key ){
					if ( key ) return players[ key ].animationController;
					return players[ this.value ].animationController;
				};

				select.getSkeletonHelper = function( key ){
					if ( key ) return players[ key ].skeletonHelper;
					return players[ this.value ].skeletonHelper;
				};

				select.addMotion = function( name, clip ){
					for ( var key in players ) {
						if ( !( key && players[key] ) ) return;
						var animationController = this.getAnimationController( key );
					//	if ( animationController.motion[ name ] ) return; // or let to replace motion?
						var mixer = animationController.mixer;
						var object = animationController.object;
						animationController.motion[ name ] = mixer.clipAction( clip, object );
					}
				};

				row.appendChild( select );
				tab.appendChild( row );

			})();

		</script>

		<script>

		//	Animation tab.

			(function(){

			//	Animation droplist.

				currentAnimation = "idling";
				var animations = []; // local.

				var tab = TabUI.Animations.tab;
				var row = document.createElement("h3");
				row.style.cssText = "padding-right:0px;";
				row.textContent = "Animation:";

				var select = document.createElement("select");
			//	select.animations = {}; // important!
				select.id = "animation-droplist";
				select.style.cssText = "width:180px;color:#000;float:right;"
					+ "border:1px solid;border-radius:4px;padding:2px 4px 4px 4px;"
					+ "font-size:20px;margin-left:10px;";

				(function(){
					var option = document.createElement("option");
					option.text = option.value = currentAnimation;
					select.appendChild( option );
				})();

				select.addEventListener( "change", function(){
					currentAnimation = this.value;
				});

				select.addEventListener( "change", function(){
					var select = document.getElementById("players-droplist");
					var animationController = select.getAnimationController( currentPlayer );
					if ( !( select && animationController ) ) return; 
					if ( !animationController.motion.idling ) return;
					animationController.play( "idling" );
				});

				select.addAnimation = function( name, clip ){
					animations.push( clip );
					var option = document.createElement("option");
					option.text = option.value = name;
					this.appendChild( option );
				};

				select.getAnimationByName = function( name ){
					return animations.find(function( clip ){
						return clip.name == name;
					});
				};
				
				select.getAnimationByUUID = function( uuid ){
					return animations.find(function( clip ){
						return clip.uuid == uuid;
					});
				};

				select.getAnimations = function(){
					return animations;
				};

				row.appendChild( select );
				tab.appendChild( row );

			})();


			(function(){

			//	Animation Test Button.

				var tab = TabUI.Animations.tab;
				var row = document.createElement("div");
				row.style.cssText = "margin:20px 12px 10px;height:35px;text-align:center;";

				var button1 = IdleButton();
				var button2 = TestButton();
				row.appendChild( button1 );
				row.appendChild( button2 );

				tab.appendChild( row );

				function IdleButton(){

					var button = document.createElement("div");
					button.id = "idle-animation";
					button.textContent = "Pause";
					button.title = "Pause animation action";
					button.style.cssText = "width:33%;float:left;height:40px;font-size:large;";
					button.classList.add( "form-control", "btn", "btn-primary", "btn-white-outline", "gradient-btn" );
					button.addEventListener( "click", function(){
						var select = document.getElementById("players-droplist");
						var animationController = select.getAnimationController( currentPlayer );
						if ( animationController.currentMotionName == "idling" ) return;
						animationController.play( "idling" ); 
					});

					return button;
				}

				function TestButton() {

					var button = document.createElement("div");
					button.id = "play-animation";
					button.textContent = "Test animation";
					button.title = "Test animation action";

					button.style.cssText = "width:65%;float:right;height:40px;font-size:large;";
					button.classList.add( "form-control", "btn", "btn-primary", "btn-white-outline", "gradient-btn" );
					button.addEventListener( "click", function(){
						var select = document.getElementById("players-droplist");
						var animationController = select.getAnimationController( currentPlayer );
					//	if ( animationController.currentMotionName == currentAnimation ) return;
						animationController.motion[currentAnimation].reset();
						animationController.play( currentAnimation );
					});

					return button;
				}

			})();


			(function(){

			//	Action Add Button.

				var idleInterval; // important!

				var tab = TabUI.Animations.tab;
				var row = document.createElement("div");
				row.style.cssText = "margin:20px 12px 10px;height:35px;text-align:center;";

				var addButton = AddActionButton();
				var rmvButton = RemoveActionButton();

				row.appendChild( rmvButton );
				row.appendChild( addButton );

				tab.appendChild( row );

				function AddActionButton(){

					var button = document.createElement("div");
					button.id = "add-action";
					button.textContent = "Add Action";
					button.title = "Add action button";
					button.style.cssText = "width:49%;height:40px;float:right;font-size:large;";
					button.classList.add( "form-control", "btn", "btn-primary", "btn-white-outline", "gradient-btn" );
					button.addEventListener( "click", function(){

						if ( currentAnimation == "idling" ) return;
						if ( document.getElementById( currentAnimation ) ) return;
						
						var animationDroplist = document.getElementById("animation-droplist");
						if ( !animationDroplist.getAnimationByName( currentAnimation ) ) return;

						var clip = animationDroplist.getAnimationByName( currentAnimation );
						document.getElementById("players-droplist").addMotion( currentAnimation, clip );

						var actionButton = document.createElement("div");
						actionButton.id = currentAnimation;
						actionButton.title = currentAnimation;
						actionButton.classList.add("btn", "btn-white-outline", "btn-action");
						actionButton.style.cssText = "background-size:contain;"
						+ "background-image:url('/manny/animations/thumbs/"+currentAnimation+".png');";

						actionButton.addEventListener( "click", function(){  /* TODO */  });

						document.getElementById("action-buttons").appendChild( actionButton );

					});

					return button;
				}

				function RemoveActionButton(){

					var button = document.createElement("div");
					button.id = "remove-action";
					button.textContent = "Remove";
					button.title = "Remove action button";
					button.style.cssText = "width:49%;height:40px;float:left;font-size:large;";
					button.classList.add( "form-control", "btn", "btn-primary", "btn-white-outline", "gradient-btn" );
					button.addEventListener( "click", function(){
						if ( !document.getElementById(currentAnimation) ) return;
						document.getElementById(currentAnimation).remove();
					});

					return button;
				}

			})();

			setTimeout(function(){

			//	Animation Import Button.

				var tab = TabUI.Animations.tab;
				var row = document.createElement("div");
				row.style.cssText = "margin:20px 12px 10px;height:35px;text-align:center;";

				var button = document.createElement("div");
				button.id = "import-animation";
				button.textContent = "Import animations";
				button.style.cssText = "width:100%;height:40px;font-size:large;";
				button.classList.add( "form-control", "btn", "btn-primary", "btn-white-outline", "gradient-btn" );

				var input = document.createElement("input");
				input.type = "file";
				input.style.display = "none";
				input.setAttribute("multiple", "");

				var k = 0; // important!

				input.addEventListener( "change", function(){

					var select = document.getElementById("animation-droplist");
					if ( !select ) { input.value = ""; return; }

					for ( var i = 0; i < input.files.length; i++ ) {
						(function( file ){

							var filename = file.name.replace(".fbx", "");
							var extension = file.name.split( "." ).pop().toLowerCase();

							var reader = new FileReader();

							reader.addEventListener( "progress", function ( e ) {
								var size = "(" + Math.floor( e.total / 1000 ).format() + " KB)";
								var progress = Math.floor( ( e.loaded / e.total ) * 100 ) + "%";
							//	debugMode && console.log( "Loading", filename, size, progress );
							});

							reader.addEventListener( "load", function ( e ) {

								var data = reader.result;
								var loader = new THREE.FBXLoader();
								var group = loader.parse( data );
							//	debugMode && console.log( group.animations );

								if ( !( group.animations && group.animations.length ) ) return;

							//	Add animations.
								group.animations.forEach( function( clip ){

									clip.name = filename;

									document.getElementById("animation-droplist").addAnimation( filename, clip );

								});

							}, false );

							reader.readAsArrayBuffer( file );

						})( input.files[i] );
					}

				});

				button.addEventListener( "click", function(){

					input.value = "";
					input.click();

				});

				button.appendChild( input );
				row.appendChild( button );
				tab.appendChild( row );

			});

		</script>

		<script>

		//	Game tab.

			var P1, P2;
			isFighting = false;

			(function(){

			//	Action buttons container.

				var tab = TabUI.Game.tab;
				var container = document.createElement("div");
				container.id = "action-buttons";
				container.style.cssText = "width:101%;max-height:300px;text-align:center;"
					+ "margin-top:20px;margin-bottom:20px;overflow-y:auto;";
				tab.appendChild( container );

			})();

		//	Lets load some animations.

			(function(){

				var swordfiles = [
					"great sword slash.fbx",
					"great sword slash (2).fbx",
					"great sword slash (3).fbx",
					"great sword slash (4).fbx",
					"great sword slash (5).fbx",
				];

				swordfiles.forEach( function( filename ){
					var loader = new THREE.FBXLoader();
					loader.load( escape("/manny/animations/sword/"+filename), function( group ){
						if ( !( group.animations && group.animations.length ) ) return;

						var clip = group.animations[0];
						clip.name = filename.replace(".fbx", "");

						document.getElementById("animation-droplist").addAnimation( clip.name, clip );

						AddActionButton( clip, "Hit Reaction From The Front With Bow (2)" );

					});
				});

				var kickfiles = [
					"A Roundhouse Kick To The Side Of An Opponent.fbx",
					"Aerial 360 Degree Front Side Rotation Kick With Rear Foot.fbx",
				];

				kickfiles.forEach(function( filename ){
					var loader = new THREE.FBXLoader();
					loader.load( escape("/manny/animations/kick/"+filename), function( group ){
						if ( !( group.animations && group.animations.length ) ) return;

						var clip = group.animations[0];
						clip.name = filename.replace(".fbx", "");

						document.getElementById("animation-droplist").addAnimation( clip.name, clip );

						AddActionButton( clip, "Hit In The Shoulder And Falls To The Ground" );

					});
				});

				var reactionfiles = [
					"Hit Reaction From The Front With Bow.fbx",
					"Hit Reaction From The Front With Bow (1).fbx",
					"Hit Reaction From The Front With Bow (2).fbx",
					"Hit In The Shoulder And Falls To The Ground.fbx",
				];

				reactionfiles.forEach(function( filename ){
					var loader = new THREE.FBXLoader();
					loader.load( escape("/manny/animations/reaction/"+filename), function( group ){
						if ( !( group.animations && group.animations.length ) ) return;

						var clip = group.animations[0];
						clip.name = filename.replace(".fbx", "");

						document.getElementById("animation-droplist").addAnimation( clip.name, clip );
					});
				});

				function AddActionButton( clip, reaction ){

					var interval;
					if ( !reaction ) reaction = "Hit Reaction From The Front With Bow (2)";
					
					var button = document.createElement("div");
					button.id = button.title = clip.name;
					button.classList.add("btn", "btn-white-outline", "btn-action");
					button.style.cssText = "background-size:contain;background-color:#fff;"
					+ "background-image:url('/manny/animations/thumbs/"+clip.name+".png');";

					document.getElementById("action-buttons").appendChild( button );

					button.addEventListener( "click", function clickHandler(){
						var select = document.getElementById("players-droplist");
						var animationController = select.getAnimationController( currentPlayer );
						animationController.action_queue.unshift( clip.name ); // important!
						setTimeout( function(){
							animationController.mixer.dispatchEvent({type:"finished"});
						});
					});

				}

			})();

		</script>

		<script>

		//	New game.
			
			(function(){

				var intersectHead = new THREE.Mesh(
					new THREE.SphereGeometry( 2, 6, 4 ),
					new THREE.MeshBasicMaterial({color:0xffff00,  wireframe:true})
				); 

				var intersectBody = new THREE.Mesh(
					new THREE.SphereGeometry( 4, 6, 4 ),
					new THREE.MeshBasicMaterial({color:0xffff00,  wireframe:true})
				);

			//	at "/manny/js/three.js" (r96) we comment line 43269: 
			//	"if ( object.visible === false ) return;" to accept 
			//	invisible objects raycasting.

				intersectHead.visible = intersectBody.visible = debugMode;

			//	Health.

				P1 = { 
					health:0, 
					intersectHead: intersectHead.clone(), 
					intersectBody: intersectBody.clone(),
				};

				P2 = { 
					health:0, 
					intersectHead: intersectHead.clone(), 
					intersectBody: intersectBody.clone(),
				};

				(function(){

					var keys = ( "Hips,LeftHand,LeftHandIndex,LeftLeg,LeftFoot,LeftToe,"
					+ "RightHand,RightHandIndex,RightHandSword,RightLeg,RightFoot,RightToe"
					).split(",");

					keys.forEach(function( key ){ 
						P1[ key ] = new THREE.Object3D();  
						P2[ key ] = new THREE.Object3D(); 
					});

				})();

			})();


		//	health bar player 1.

			(function(){

				var bar = document.createElement("div");
				bar.title = "Player1 Health Bar";
				bar.style.cssText = "width:350px;height:40px;position:fixed;top:10px;"
					+ "border:2px solid #fff;border-radius:8px;background-color:#f00;right:380px;";

				var label = document.createElement("span");
				label.textContent = "Player 1";
				label.style.cssText = "position:absolute;color:#fff;"
					+ "font-weight:bold;font-size:x-large;left:-100px;";
				bar.appendChild( label );

				var health_bar = document.createElement("div");
				health_bar.id = "player1-health-bar";
				health_bar.style.cssText = "width:100%;height:100%;"
					+ "background-color:#ff0;float:left;border-radius:4px;";
				bar.appendChild( health_bar );

				var text_bar = document.createElement("div");
				text_bar.style.cssText = "width:100%;text-align:center;background:none;"
					+ "position:absolute;font-weight:bold;color:#fff;font-size:x-large;";
				text_bar.textContent = P1.health+"%";
				bar.appendChild( text_bar );

				P1.appendBar = function(){
					document.body.appendChild( bar );
				};

				P1.removeBar = function(){
					bar.remove();
				};

				P1.healthWacher = function(prop, action, value){
					health_bar.style.width = round( value, 1 ) + "%";
					text_bar.textContent = health_bar.style.width;
					if ( value > 0 ) label.style.color = "#fff";
					else label.style.color = "#f00";
				};

				P1.blink = blink.bind( P1, label );

				watch( P1, "health", P1.healthWacher );

			})();

		//	health bar player 2.

			(function(){

				var bar = document.createElement("div");
				bar.title = "Player2 Health Bar";
				bar.style.cssText = "width:350px;height:40px;position:fixed;top:10px;"
					+ "border:2px solid #fff;border-radius:8px;background-color:#f00;left:10px;";

				var label = document.createElement("span");
				label.textContent = "Player 2";
				label.style.cssText = "position:absolute;color:#fff;"
					+ "font-weight:bold;font-size:x-large;right:-100px";
				bar.appendChild( label );

				var health_bar = document.createElement("div");
				health_bar.id = "player2-health-bar";
				health_bar.style.cssText = "width:100%;height:100%;border-radius:4px;"
					+ "background-color:#ff0;float:right;";
				bar.appendChild( health_bar );

				var text_bar = document.createElement("div");
				text_bar.style.cssText = "width:100%;text-align:center;background:none;"
					+ "position:absolute;font-weight:bold;color:#fff;font-size:x-large;";
				text_bar.textContent = P2.health+"%";
				bar.appendChild( text_bar );

				P2.appendBar = function(){
					document.body.appendChild( bar );
				};

				P2.removeBar = function(){
					bar.remove();
				};

				P2.healthWacher = function(prop, action, value){
					health_bar.style.width = round( value, 1 ) + "%";
					text_bar.textContent = health_bar.style.width;
					if ( value > 0 ) label.style.color = "#fff";
					else label.style.color = "#f00";
				};

				P2.blink = blink.bind( P2, label );

				watch( P2, "health", P2.healthWacher );

			})();

			function blink( label ){
				var display;
				setTimeout( function _blink(){

					if ( isFighting ) {
						label.style.display = "";
						return;
					}

					display = !display;

					if ( display ) 
						label.style.display = "";
					else 
						label.style.display = "none";

					setTimeout( _blink, 650 );

				});
			}

		//	Start game button.

			setTimeout(function(){

				var tab = TabUI.Game.tab;
				var row = document.createElement("div");
				row.style.cssText = "margin:20px 12px 10px;height:35px;text-align:center;";

				var button = document.createElement("div");
				button.id = "start-raycasting";
				button.textContent = "Start Battle";
				button.style.cssText = "max-width:100%;width:100%;height:40px;font-size:large;";
				button.classList.add( "form-control", "btn", "btn-primary", "btn-white-outline", "gradient-btn" );
				button.addEventListener( "click", function(){ 
					button.value = !button.value; 
				});

				row.appendChild( button );
				tab.appendChild( row );

				watch( button, "value", function showtime(prop, action, value){

					isFighting = value; debugMode && console.log( "isFighting:", isFighting );

					if ( value ) button.textContent = "Pause Battle";
					else if ( !value ) button.textContent = "Start Battle";

					var player1 = scene.getObjectByName( "player1" );
					var player2 = scene.getObjectByName( "player2" );

					var playersDroplist = document.getElementById("players-droplist");
					var animationDroplist = document.getElementById("animation-droplist");

					P1.name = player1.name; P2.name = player2.name;

					P1.skeletonHelper = playersDroplist.getSkeletonHelper("player1");
					P2.skeletonHelper = playersDroplist.getSkeletonHelper("player2");
					P1.animationController = playersDroplist.getAnimationController("player1");
					P2.animationController = playersDroplist.getAnimationController("player2");
					P1.animationController.play( "idling" ); P2.animationController.play( "idling" ); 

					if ( value ) { P1.appendBar();  P2.appendBar(); }

					if ( !value && (P1.health && P2.health) ) {
						button.textContent = "Continue Battle";
					} else if ( !value && !(P1.health && P2.health) ) {
						button.textContent = "New Battle";
					}

					if ( value && !(P1.health && P2.health) ) {
						P1.health = 100; P2.health = 100; // important!
					}

					if ( !isFighting ) {
						P1.animationController.turn(0); 
						P2.animationController.turn(0);
					} else {
						P1.animationController.turn(-Math.PI/2); 
						P2.animationController.turn(Math.PI/2);
					}

					//	stop battle.

					if ( isFighting ) (function update(){

						if ( P1.health < 0 ) {
							P1.health = 0;  
							isFighting = false;
							button.value = false; 
							P2.health && P2.blink();
							setTimeout( function(){
								winner(P2); looser(P1);
							});
							return;

						} else if ( P2.health < 0 ) {
							P2.health = 0; 
							isFighting = false;
							button.value = false; 
							P1.health && P1.blink();
							setTimeout( function(){
								winner(P1); looser(P2);
							});
							return;
						}

						if ( !isFighting ) { 
							if ( P1.health > 0 ) P1.blink();
							if ( P2.health > 0 ) P2.blink();
							return; 
						}

						setTimeout( update, 1000 );

						function winner(p){
							var name = "Aerial 360 Degree Front Side Rotation Kick With Rear Foot";
							p.animationController.play( name );
							p.animationController.motion[ name ].reset();
						}

						function looser(p){
							var name = "Hit In The Shoulder And Falls To The Ground";
							p.animationController.motion[ name ].clampWhenFinished = true;
							p.animationController.motion[ name ].setLoop(THREE.LoopOnce);
							p.animationController.play( name );
							p.animationController.motion[ name ].reset();
						}

					})();

					if ( isFighting ) {
						P1.intersectHead.visible = P1.intersectBody.visible = debugMode;
						P2.intersectHead.visible = P2.intersectBody.visible = debugMode;
					}

					if ( isFighting ) {

						scene.add(P1.intersectHead, P1.intersectBody);
						scene.add(P2.intersectHead, P2.intersectBody);

					} else {

						scene.remove(P1.intersectHead, P1.intersectBody);
						scene.remove(P2.intersectHead, P2.intersectBody);

					}

					if ( isFighting ) {

						updatePointObjects( P1 ); // important!
						updatePointObjects( P2 ); // important!

					}

					if ( isFighting ) {

						if ( currentPlayer == "player1" ) randomStartUpAction( P2 ); 
						if ( currentPlayer == "player2" ) randomStartUpAction( P1 );

					}

					if ( debugMode ) {
						player1.visible = player2.visible = !isFighting; 
						P1.skeletonHelper.visible = P2.skeletonHelper.visible = isFighting;
					}

				}); // end watch().

			}); // end setTimeout().


			function updatePointObjects( p ){

				var player = scene.getObjectByName( p.name );

				if ( !player ) return;

				var hipsBone = player.getObjectByName("Hips");

				var headBone = player.getObjectByName("Head");
				var bodyBone = player.getObjectByName("Spine");

				var leftlegBone = player.getObjectByName("LeftLeg");
				var leftfootBone = player.getObjectByName("LeftFoot");
				var lefttoeBone = player.getObjectByName("LeftToeBase");
				var lefthandBone = player.getObjectByName("LeftHand");
				var leftindexBone = player.getObjectByName("LeftHandIndex1");

				var rightlegBone = player.getObjectByName("RightLeg");
				var rightfootBone = player.getObjectByName("RightFoot");
				var righttoeBone = player.getObjectByName("RightToeBase");
				var righthandBone = player.getObjectByName("RightHand");
				var rightindexBone = player.getObjectByName("RightHandIndex1");
				var rightswordBone = player.getObjectByName("RightHandIndex1Sword");

				(function update(){
					var requestAnimationFrameID = requestAnimationFrame( update );

					if ( !isFighting ) cancelAnimationFrame( requestAnimationFrameID ); // return; 

					p.intersectHead.position.setFromMatrixPosition(headBone.matrixWorld);
					p.intersectBody.position.setFromMatrixPosition(bodyBone.matrixWorld);
					p.Hips.position.setFromMatrixPosition(hipsBone.matrixWorld);
					p.LeftHand.position.setFromMatrixPosition(lefthandBone.matrixWorld);
					p.LeftHandIndex.position.setFromMatrixPosition(leftindexBone.matrixWorld);
					p.LeftLeg.position.setFromMatrixPosition(leftlegBone.matrixWorld);
					p.LeftFoot.position.setFromMatrixPosition(leftfootBone.matrixWorld);
					p.LeftToe.position.setFromMatrixPosition(lefttoeBone.matrixWorld);
					p.RightLeg.position.setFromMatrixPosition(rightlegBone.matrixWorld);
					p.RightFoot.position.setFromMatrixPosition(rightfootBone.matrixWorld);
					p.RightToe.position.setFromMatrixPosition(righttoeBone.matrixWorld);
					p.RightHand.position.setFromMatrixPosition(righthandBone.matrixWorld);
					p.RightHandIndex.position.setFromMatrixPosition(rightindexBone.matrixWorld);
					p.RightHandSword.position.setFromMatrixPosition(rightswordBone.matrixWorld);

				})();

			} // end updatePointObjects.

			function randomStartUpAction( p ){

				if ( !isFighting ) return;

				var ignorekeys = [ 
					"Hit Reaction From The Front With Bow",
					"Hit Reaction From The Front With Bow (1)",
					"Hit Reaction From The Front With Bow (2)",
					"Hit In The Shoulder And Falls To The Ground"
				];

			//	var reaction = "Hit Reaction From The Front With Bow (2)";
			//	var reaction = "Hit In The Shoulder And Falls To The Ground";

				var clips = document.getElementById("animation-droplist").getAnimations();

				var names = clips.map(function( clip ){ 
					return clip.name; 
				}).filter( function( name ){
					return !ignorekeys.includes( name );
				});

				if ( !p.animationController.action_queue.length ) {
					
					update();

				} else {

					setTimeout( update, 3000 );

					p.animationController.mixer.dispatchEvent({type:"finished"}); // important!
				}

				function update(){

					if ( !isFighting ) return;

					var name = names[ parseInt( Math.random() * names.length ) ];
					while ( ignorekeys.includes( name ) ) {
						name = names[ parseInt( Math.random() * names.length ) ];
					}

				//	send a delayed "finished" event if "action_queue" is empty. hack!
					if ( !p.animationController.action_queue.length ) setTimeout(function(){
						p.animationController.mixer.dispatchEvent({type:"finished"}); // important!
					}, 100);

					p.animationController.action_queue.push( name );

					if ( isFighting ) setTimeout( update, 3000 );

				}

			}





		</script>

		<script>

		//	Load Player 1.
			
			(function(name, s, x){

				var loader = new THREE.FBXLoader();
				loader.load( "/manny/characters/MannySwordIdle04.fbx", function( player ){

				//	player is a THREE.Group.

				//	var s = 0.00033; 
					player.name = name; // "player1";
					player.scale.set(s,s,s); // important!
					player.position.x = x; // 10;
					scene.add( player );

					var bones = {}; 	// create bone options. TODO!
					var meshes = {};	// create mesh options. TODO!
					var wepons = {};	// create wepon options. TODO!
					var skinned = {};	// create skinned options. TODO!
					var helpers = {};
					var armature; 		// THREE.Group.
					var animations = player.animations;

					player.traverse( function( child ){

						if (child.name == "Armature") { 
							armature = child; 
						}

						if (child.isMesh) {	
							child.castShadow = true;	
							child.receiveShadow = true;	
							meshes[ child.name ] = child;
						}

						if ( child.isBone ) {
							bones[ child.name ] = child;
						}

						if ( child.isSkinnedMesh ) {
							skinned[ child.uuid ] = child;
						}

						if (child.name == "sword") {
							sword1 = child; // debug!
							wepons[ child.name ] = child;
						}

						if (child.name == "MannyTheSkeleton_v51") {
							(function(mesh){

							//	replace material.
								mesh.material = new THREE.MeshStandardMaterial({
									name:"player1_Material", skinning:true, // important!
								});

								var loader = new THREE.ImageLoader();
								loader.setCrossOrigin("anonymous"); // important!
								var src = "https://i.imgur.com/rxUXS8C.png";
								loader.load( src, function( image ){
									var mapping = THREE.SphericalReflectionMapping;		// important!
									var texture = new THREE.Texture( image, mapping );	// important!
									mesh.material.roughness = 0; 
									mesh.material.metalness = 1; 
									mesh.material.envMap = texture; 
									mesh.material.envMap.needsUpdate = true; 
									mesh.material.needsUpdate = true;
								});

								debugMode && console.log( mesh.material ); 

							})( child );
						}

					});

				//	Add Sword bone. important!

					(function(){
						var bone = new THREE.Bone();
						bone.name = "RightHandIndex1Sword";
						bone.position.set(200, 20, -80); // importrant!
						player.getObjectByName("RightHandIndex1").add(bone);
					})();

				//	Skeleton helper (for debug).

					(function(){
						var skeletonHelper = new THREE.SkeletonHelper( player );
						skeletonHelper.visible = debugMode;
						scene.add( skeletonHelper );
						helpers.skeletonHelper = skeletonHelper;
						debugMode && console.log( skeletonHelper );
					})();

				//	characters contains only idle animation.
					if ( animations && animations.length ) player.animations[0].name = "idling";

				//	Animation controller.
					var animationController = new MW.AnimationController( player );

					animationController.action_queue = []; // important!

				//	play idling.
					if ( animationController.motion.idling ) animationController.play("idling");

				//	raycaster.

					(function raycaster(){

						var requestAnimationFrameID; // important?
						var reaction = "Hit Reaction From The Front With Bow (2)";

					//	raycaster.
						var origin = new THREE.Vector3();
						var direction = new THREE.Vector3();
						var intersectObjects = [ P2.intersectBody, P2.intersectHead ];
						var raycaster = new THREE.Raycaster(); 
						raycaster.far = 9;

						var arrow = new THREE.ArrowHelper( 
							raycaster.ray.direction, 
							raycaster.ray.origin, 
							raycaster.far 
						);

						animationController.mixer.addEventListener( "finished", function(e){

							cancelAnimationFrame( requestAnimationFrameID ); // cancel last raycaster update.
							if ( arrow && arrow.parent ) scene.remove( arrow ); // remove last arrow helper.

							if ( !isFighting ) return;

							if ( !animationController.action_queue.length ) {
								animationController.play( "idling" ); return;
							}

						//	starting next action.

							if ( debugMode ) scene.add( arrow );

						//	raycaster update.
							(function update(){

								requestAnimationFrameID = requestAnimationFrame( update );

							//	stop if not fighting.
								if ( !isFighting ) {
									cancelAnimationFrame( requestAnimationFrameID );
									if ( arrow && arrow.parent ) scene.remove( arrow );
									return;
								}

								origin.copy( P1.RightHandIndex.position );

								direction.subVectors(
									P1.RightHandSword.position, // direction,
									P1.RightHandIndex.position // origin
								).normalize();  // must be noramlized!

								raycaster.ray.set( origin, direction );


							//	arrow helper.
								if ( arrow && arrow.parent ) { 
									arrow.position.copy( raycaster.ray.origin );
									arrow.setDirection( raycaster.ray.direction  );
								}

								var intersects = raycaster.intersectObjects( intersectObjects );

								if ( !intersects.length ) return;

							//	stop if hit intersects.
								cancelAnimationFrame( requestAnimationFrameID ); // important!
							//	if ( arrow && arrow.parent ) scene.remove( arrow ); 

							//	player 2 reaction.
								P2.animationController.play( reaction ); 
								P2.animationController.motion[ reaction ].reset(); 
								debugMode && console.log( "reaction player 2:", reaction );

							//	player 2 health.
								P2.health -= (raycaster.far - intersects[0].distance); // (...)/10; or (...)/100;

							})();

						//	player 1 action.
							var key = animationController.action_queue.shift();
							animationController.play( key ); 
							animationController.motion[ key ].reset();
							debugMode && console.log( "player 1:", key );

						}); // end raycasterEventHandler.

					})(); // end raycaster player 1.


				//	bind animations.
					(function( select ){
						var mixer = animationController.mixer; 
						var object = animationController.object;
						select.getAnimations().forEach(function( clip ){
							var clipAction = mixer.clipAction( clip, object );
							animationController.motion[ clip.name ] = clipAction;
							animationController.motion[ clip.name ].setLoop(THREE.LoopOnce);
							animationController.motion[ clip.name ].clampWhenFinished = true;
						});
					})( document.getElementById("animation-droplist") );

				//	start updating.
					var clock = new THREE.Clock();
					(function update(){
						requestAnimationFrame( update );
						var delta = clock.getDelta();
						animationController.update( delta );
					})();

				//	Players droplist.
					(function( select ){
						if ( !select ) return;

						var object = {
							name: player.name,
							uuid: player.uuid, // THREE.Math.generateUUID(),
						};

						if ( animationController ) {
							object.animationController = animationController;
						}

						if ( helpers.skeletonHelper ) {
							object.skeletonHelper = helpers.skeletonHelper;
						}

						select.addPlayer( player.name, object, true);
					})( document.getElementById("players-droplist") );

				},

				function(e){}, 
				function(err){
					console.error(err);
				});

			})("player1", 0.00033, 10);


		</script>

		<script>

		//	Load Player.

			loadPlayer( "player2", 0.00033, -10 );

			function loadPlayer(name, s, x){

				var loader = new THREE.FBXLoader();
				loader.load( "/manny/characters/MannySwordIdle05.fbx", function( player ){

				//	player is a THREE.Group.

				//	var s = 0.00033; 
					player.name = name; // "player1";
					player.scale.set(s,s,s); // important!
					player.position.x = x;
					scene.add( player );

					var bones = {}; 	// create bone options. TODO!
					var meshes = {};	// create mesh options. TODO!
					var wepons = {};	// create wepon options. TODO!
					var skinned = {};	// create skinned options. TODO!
					var helpers = {};
					var armature; 		// THREE.Group.
					var animations = player.animations;

					player.traverse( function( child ){

						if (child.name == "Armature") { 
							armature = child; 
						}

						if (child.isMesh) {	
							child.castShadow = true;	
							child.receiveShadow = true;	
							meshes[ child.name ] = child;
						}

						if ( child.isBone ) {
							bones[ child.name ] = child;
						}

						if ( child.isSkinnedMesh ) {
							skinned[ child.uuid ] = child;
						}

						if (child.name == "sword") {
							sword1 = child; // debug!
							wepons[ child.name ] = child;
						}

						if (child.name == "MannyTheSkeleton_v51") {
							(function(mesh){

							//	replace material.
								mesh.material = new THREE.MeshStandardMaterial({
									name:"player1_Material", skinning:true, // important!
								});

								var loader = new THREE.ImageLoader();
								loader.setCrossOrigin("anonymous"); // important!
								var src = "https://i.imgur.com/Fx9154f.png";
								loader.load( src, function( image ){
									var mapping = THREE.SphericalReflectionMapping;		// important!
									var texture = new THREE.Texture( image, mapping );	// important!
									mesh.material.roughness = 0; 
									mesh.material.metalness = 1; 
									mesh.material.envMap = texture; 
									mesh.material.envMap.needsUpdate = true; 
									mesh.material.needsUpdate = true;
								});

								debugMode && console.log( mesh.material ); 

							})( child );
						}

					});

				//	Add Sword bone. important!

					(function(){
						var bone = new THREE.Bone();
						bone.name = "RightHandIndex1Sword";
						bone.position.set(200, 20, -80); // importrant!
						player.getObjectByName("RightHandIndex1").add(bone);
					})();

				//	Skeleton helper (for debug).

					(function(){
						var skeletonHelper = new THREE.SkeletonHelper( player );
						skeletonHelper.visible = debugMode;
						scene.add( skeletonHelper );
						helpers.skeletonHelper = skeletonHelper;
						debugMode && console.log( skeletonHelper );
					})();

				//	characters contains only idle animation.
					if ( animations && animations.length ) player.animations[0].name = "idling";

				//	Animation controller.
					var animationController = new MW.AnimationController( player );

					animationController.action_queue = []; // important!

				//	play idling.
					if ( animationController.motion.idling ) animationController.play("idling");

				//	raycaster.

					(function raycaster(){

						var requestAnimationFrameID; // important?
						var reaction = "Hit Reaction From The Front With Bow (2)";

					//	raycaster.
						var origin = new THREE.Vector3();
						var direction = new THREE.Vector3();
						var intersectObjects = [ P1.intersectBody, P1.intersectHead ];
						var raycaster = new THREE.Raycaster(); 
						raycaster.far = 9;

						var arrow = new THREE.ArrowHelper( 
							raycaster.ray.direction, 
							raycaster.ray.origin, 
							raycaster.far 
						);

						animationController.mixer.addEventListener( "finished", function raycasterEventHandler(e){

							cancelAnimationFrame( requestAnimationFrameID ); // cancel last raycaster update.
							if ( arrow && arrow.parent ) scene.remove( arrow ); // remove last arrow helper.

							if ( !isFighting ) return;

							if ( !animationController.action_queue.length ) {
								animationController.play( "idling" ); return;
							}

						//	starting next action.

							if ( debugMode ) scene.add( arrow );

						//	raycaster update.
							(function update(){

								requestAnimationFrameID = requestAnimationFrame( update );

							//	stop if not fighting.
								if ( !isFighting ) {
									cancelAnimationFrame( requestAnimationFrameID );
									if ( arrow && arrow.parent ) scene.remove( arrow );
									return;
								}

								origin.copy( P2.RightHandIndex.position );

								direction.subVectors(
									P2.RightHandSword.position, // direction,
									P2.RightHandIndex.position // origin
								).normalize();  // must be noramlized!

								raycaster.ray.set( origin, direction );

							//	arrow helper.
								if ( arrow && arrow.parent ) { 
									arrow.position.copy( raycaster.ray.origin );
									arrow.setDirection( raycaster.ray.direction  );
								}

								var intersects = raycaster.intersectObjects( intersectObjects );

								if ( !intersects.length ) return;

							//	stop raycasting if hit intersects?
								cancelAnimationFrame( requestAnimationFrameID ); // important!
							//	if ( arrow && arrow.parent ) scene.remove( arrow ); 

							//	player 1 reaction.
								P1.animationController.play( reaction ); 
								P1.animationController.motion[ reaction ].reset(); 
								debugMode && console.log( "reaction player 1:", reaction );

							//	player 1 health.
								P1.health -= (raycaster.far - intersects[0].distance); // (...)/10; or (...)/100;

							})();

						//	player 2 action.
							var key = animationController.action_queue.shift();
							animationController.play( key ); 
							animationController.motion[ key ].reset();
							debugMode && console.log( "player 2:", key );

						}); // end raycasterEventHandler.

					})(); // end raycaster player 2.

				//	bind animations.
					(function( select ){
						var mixer = animationController.mixer; 
						var object = animationController.object;
						select.getAnimations().forEach(function( clip ){
							var clipAction = mixer.clipAction( clip, object );
							animationController.motion[ clip.name ] = clipAction;
							animationController.motion[ clip.name ].setLoop(THREE.LoopOnce);
							animationController.motion[ clip.name ].clampWhenFinished = true;
						});
					})( document.getElementById("animation-droplist") );

				//	start updating.
					var clock = new THREE.Clock();
					(function update(){
						requestAnimationFrame( update );
						var delta = clock.getDelta();
						animationController.update( delta );
					})();

				//	Players droplist.
					(function( select ){
						if ( !select ) return;

						var object = {
							name: player.name,
							uuid: player.uuid, // THREE.Math.generateUUID(),
						};

						if ( animationController ) {
							object.animationController = animationController;
						}

						if ( helpers.skeletonHelper ) {
							object.skeletonHelper = helpers.skeletonHelper;
						}

						select.addPlayer( player.name, object );
					})( document.getElementById("players-droplist") );

				},

				function(e){}, 
				function(err){
					console.error(err);
				});

			}

		</script>

		<script>

/*
				//	this is going to "finished" event handler.
					button.addEventListener( "click", function clickHandler(){
						
						button.removeEventListener( "click", clickHandler );

						var p1, p2;
						if ( currentPlayer == "player1" ) { p1 = P1; p2 = P2; }
						if ( currentPlayer == "player2" ) { p1 = P2; p2 = P1; }

						var requestAnimationFrameID; // important!
						var select = document.getElementById("players-droplist");
						var animationController = select.getAnimationController( currentPlayer );
					//	animationController.mixer.dispatchEvent({type:"finished"}); // important?

						if ( isFighting ){

							var origin = new THREE.Vector3();
							var direction = new THREE.Vector3();
							var intersectObjects = [p2.intersectBody, p2.intersectHead];
							var raycaster = new THREE.Raycaster(); raycaster.far = 9;

						//	Arrow helper.
							var arrow = new THREE.ArrowHelper( 
								raycaster.ray.direction, raycaster.ray.origin, raycaster.far 
							); if ( debugMode ) scene.add( arrow );

							(function update(){

								requestAnimationFrameID = requestAnimationFrame( update );

								origin.copy( p1.RightHandIndex.position );

								direction.subVectors(
									p1.RightHandSword.position, // direction,
									p1.RightHandIndex.position // origin
								).normalize();  // must be noramlized!

								raycaster.ray.set( origin, direction );

							//	Arrow helper.
								if ( arrow && arrow.parent ) { 
									arrow.position.copy( raycaster.ray.origin );
									arrow.setDirection( raycaster.ray.direction  );
								}

								var intersects = raycaster.intersectObjects( intersectObjects );

								if ( !intersects.length ) return;

								cancelAnimationFrame( requestAnimationFrameID ); // important!
								p2.health -= (raycaster.far - intersects[0].distance); // (...)/10; or (...)/100;
								p2.animationController.play( reaction ); 
								p2.animationController.motion[ reaction ].reset();

							})();

						} // end if (isFighting)

						animationController.mixer.addEventListener( "finished", function finishedEventHandler(e){

							cancelAnimationFrame( requestAnimationFrameID ); // important!

							setTimeout( function(){ 
								animationController.mixer.removeEventListener( "finished", finishedEventHandler ); // important!
								debugMode && console.log( clip.name, "finished:", e );
							});

							setTimeout( function(){ 
								button.addEventListener( "click", clickHandler ); 
								debugMode && console.log( clip.name, "button is ready." );
							});

							scene.remove( arrow );

							animationController.play( "idling" );
						});

						animationController.play( clip.name ); 
						animationController.motion[ clip.name ].reset();

					});
*/

/*
						var requestAnimationFrameID; // important!

						var origin = new THREE.Vector3();
						var direction = new THREE.Vector3();
						var intersectObjects = [p2.intersectBody, p2.intersectHead];
						var raycaster = new THREE.Raycaster(); raycaster.far = 9;

						var arrow = new THREE.ArrowHelper( raycaster.ray.direction, raycaster.ray.origin, raycaster.far );

						animationController.mixer.addEventListener( "finished", onfinishedEventHandler );
						if ( !isFighting ) animationController.mixer.removeEventListener( "finished", onfinishedEventHandler );

						setTimeout( function(){
							if ( debugMode ) scene.add( arrow );
							animationController.mixer.dispatchEvent({type:"finished"});
						}, 3000);


						function onfinishedEventHandler( e ){

							cancelAnimationFrame( requestAnimationFrameID ); // important!

							if ( !isFighting ) {
								if (arrow && arrow.parent) scene.remove( arrow );
								cancelAnimationFrame( requestAnimationFrameID ); // important!
								this.removeEventListener( "finished", onfinishedEventHandler );
								return;
							}

							var name = names[ parseInt( Math.random() * names.length ) ];
							while ( ignorekeys.includes( name ) ) {
								name = names[ parseInt( Math.random() * names.length ) ];
							}

							(function update(){

								requestAnimationFrameID = requestAnimationFrame( update );

								origin.copy( p1.RightHandIndex.position );

								direction.subVectors(
									p1.RightHandSword.position, // direction,
									p1.RightHandIndex.position // origin
								).normalize();  // must be noramlized!

								raycaster.ray.set( origin, direction );

								//	Arrow helper.
								if ( arrow && arrow.parent ) { 
									if ( !isFighting ) scene.remove( arrow );
									arrow.position.copy( raycaster.ray.origin );
									arrow.setDirection( raycaster.ray.direction  );
								}

								var intersects = raycaster.intersectObjects( intersectObjects );

								if ( !intersects.length ) return;

								cancelAnimationFrame( requestAnimationFrameID ); // important!

								p2.health -= (raycaster.far - intersects[0].distance); // (...)/10; or (...)/100;
								p2.animationController.play( reaction );
								p2.animationController.motion[ reaction ].reset();

							})();

							animationController.play( name ); animationController.motion[ name ].reset();

						} // end onfinishedEventHandler.

*/

/*
				//	raycaster event listener.
					animationController.mixer.addEventListener( "finished", function raycastEventHandler(e){

						var p1 = P1, p2 = P2; // important!
						var requestAnimationFrameID; // important?
						var reaction = "Hit Reaction From The Front With Bow (2)";

						if ( !isFighting ) return;

						if ( !animationController.action_queue.length ) { 
							animationController.play( "idling" ); return; 
						}
						
					//	raycaster.
						var origin = new THREE.Vector3();
						var direction = new THREE.Vector3();
						var intersectObjects = [ p2.intersectBody, p2.intersectHead ];
						var raycaster = new THREE.Raycaster(); 
						raycaster.far = 9;

						var arrow;
						if ( debugMode ) {
							arrow = new THREE.ArrowHelper( 
								raycaster.ray.direction, 
								raycaster.ray.origin, 
								raycaster.far 
							);
							scene.add( arrow );
						}

					//	animationController.mixer.addEventListener( "finished", function actionfinishedEventHandler(e){
					//		animationController.mixer.removeEventListener( "finished", actionfinishedEventHandler );
					//		cancelAnimationFrame( requestAnimationFrameID ); // important!
					//		if ( arrow && arrow.parent ) scene.remove( arrow ); 
					//	});

					//	raycast update.
						(function update(){

							requestAnimationFrameID = requestAnimationFrame( update );
							debugMode && console.log( requestAnimationFrameID );

							if ( !isFighting ) {
								cancelAnimationFrame( requestAnimationFrameID );
								if ( arrow && arrow.parent ) scene.remove( arrow );
							}

							origin.copy( p1.RightHandIndex.position );

							direction.subVectors(
								p1.RightHandSword.position, // direction,
								p1.RightHandIndex.position // origin
							).normalize();  // must be noramlized!

							raycaster.ray.set( origin, direction );

						//	arrow helper.
							if ( arrow && arrow.parent ) { 
								arrow.position.copy( raycaster.ray.origin );
								arrow.setDirection( raycaster.ray.direction  );
							}

							var intersects = raycaster.intersectObjects( intersectObjects );

							if ( !intersects.length ) return;

							cancelAnimationFrame( requestAnimationFrameID ); // important!
						//	if ( arrow && arrow.parent ) scene.remove( arrow ); 

							p2.health -= (raycaster.far - intersects[0].distance); // (...)/10; or (...)/100;
							p2.animationController.action_queue.unshift( reaction );
							p2.animationController.mixer.dispatchEvent({type:"finished"});

						})();

					//	play action.
						var key = animationController.action_queue.shift();
						animationController.play( key );
						animationController.motion[ key ].reset();

					});
*/
		</script>
	</body>
</html>
